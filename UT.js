// coffeeScript.coffee: Generated by CoffeeScript 2.3.1 (coffeescript.coffee IMMED5 affects ./coffee -v)
  // process: ENV={"daemon":true,"dev":true,"mac":true,"node":true,"node8":true,"ut":true,"source":"/Users/pete/gitlab/rn/API/Flexbase/UT.coffee"}
  //if node
var A, AsyncTest, Base, EXPORTED, O, REMOVE_ME_MS, S, Section, SyncTest, Test, UT, UTBase, UTRunner, UT_UT, Util, V, aGenerate, bag, handler, log, path, proxyBag, sectionGenerate, syncTestsCount, target, testGenerate, testList, testStack, trace,
  indexOf = [].indexOf;

REMOVE_ME_MS = 10;

//else
//endif
/*			**MASTER**
YAJUT - Yet Another Javascript Unit T e s t							a.shift "pop() by doing shift LEFT"

bottom line: unit tests must be as powerful and succinct as possible... as little boilerplate as possible... and easily controllable... to isolate correct one giving you brief
    must be fast (parallel execution), vary trace easily.  quickly stop on errors
easily extendable with native commands
rich set of primatives (dump object)
logging for posterity

=> you spend most of your time writing unit tests... make it as easy and enjoyable as possible

great support for negative testing... ... ability to "unwind" errors and remove specific expected ones

non-features
human readable dot.dot.dot crap

USAGE:
yajut						run current configuration
yajut conffile				run configuration stored as JSON in text file
yajut list					list all tests in directory
yajut purgelogs				forceably purge all previous log directories and files without user confirmation
yajut resetstats			forceably reset all test statistics without user confirmation
yajut -k keyword			run all tests matching keyword
yajut -r					re-run all failed tests from the exact preceeding run
yajut -s conffile			save current code-specified configuration into confifile for manual editing or re-use later

EXTENDS: Base

DESCRIPTION:
The goal of JAJUT is to be absolutely the least-friction most-terse easiest to use JS unit test system.

use skinny arrows (not fat arrows) for nested tests:
	@s "async nesting test", ->
		@s "a", ->
			@s "b1", ->
    			@t "some sync test", ->
				@a "some async test", (ut) -> ut.resolve()

The UT, for the server, choses either a blank Flexbase database or a database with small user pool
For local, it chooses either a brand-new install, or a already established user account.
server: "blank" or "std"
client: "blank" or "std"

Everything is logged.... in fact you can do @snap to take a picture of both databases and all object state at that moment in separate data directory

Promise-based, hierarchical test, minimalist and least-boilerplate, inline with source code unit test framework.

- (ut) -> vs @utMethod: the value of 'ut' parameter is that:
    - @ form is shorter
    - but using ut: a test can use closure not fat arrows (=>) to access ut properties and methods
    - but using ut: if inside a overridden child method of a sub-class: onReceive where 'this' context is the object not the ut

EVENTS: @events
left-open
runner-done
runner-start
test-done
test-start

FEATURES
- ability to add or remove flags run-over-run: +flag  /flag or something
- almost everything is customizable: mTypes, logging, primatives (t, a, p, s, etc.)

ERRORS:
UT001 Unknown test option: $
UT002 Unknown mType=$
UT003 You are not allowed to define the method named '$' because it clashes with a built-in property

GENERALIZE:
- mType's

TODOs
- "COMMMAND" or "PRIMATIVE"... standardize!
- ut() to fulfill async?
- log EVERY run to new timestamp directory with tests ran in the directory name... store ALL data
	- two files: currently enabled trace and ALL TRACE
	- auto-zip at end
	- directory: 2018-05-01 6m tot=89 P_88 F_1 3-TestClient,DeathStar TR=UT_TEST_POST_ONE_LINER,ID_TRANSLATE.zip
		traceSelected.txt
		traceAll.txt
		src/...
- if run all TESTS report how many are disabled _
- change ut to t?
- target=SERVER command line switch
- put cleanup in opts  but that means @client and @server or implement our own timeout mechanism, again, inside here:
- onPost -> @testHub.directoryRemoveRecursiveForce()
- actually:  @testHub.directoryGetTempInstanceSpace
- test auto-discovery so don't need to explicity list in tests.coffee
- add @rnd() functions
- add milepost functionality
- validate system-level options parameter names
- validate per-unit test on-the-fly options for mispellings
- @defined x
- at beginning of test, silently dump all it's options
- EXCEPTION to check the actual type of exception... many false positives/negatives unless do THAT
- @db_log (snapshot)
- @db_diff	do snapshot into delta arrays
- only create tables once per section, and is run een if only a single test override in place... not sure how to pull this off.  @s -> if @testing ...
- auto-teardown: you register setup things and what to do with them... if anything goes wrong they are torn down
- write test results in JSON file so that can do "query" like "when was the last time this test passed?"
- children ndoes that "build" to the current overridden child node... preceeding steps...really great idea!
- designate test as a negative test... @tn... @n...  @an...?
- run all asynch tests at same time concurrently
- classify tests: positive, negative, boundary, stress, unspecified, etc.
- run all tests < or > than so many milliseconds
- node -cat  show all unit tests
- node -grep xxx   grep all matching tests
- capitalize section ("S") overrides to run entire sections
- purposeful 1000ms delay between tests to let things settle
- count the number of disabled tests
- include string diff report functions to make it really easy to ascertain why @eq fails
#EASY: dump all possible test options... in grid with S T A section/test/asynch columns in front, option, desc, and example
#EASY: new option def:
    @t "some test",
			def:
				em: "Deanna is beautiful"
				b: "b-value"
			exceptionMessage: @em			HOW DO THIS?
		, ->
			throw @em
    should be readable by ut.a, @a, and other parameters.  Ensure don't stomp on system
- have eventFire be a wrapper that calls the real cb and if not return true the call process?.exit?
- keep the same numbers, even if overrides
- manufacture variables than can be passed into routines that track what values they are set to to see if they exceed, etc.  using proxy
- run this test: UT.Peter.capitalize (local)     PASS=2 instead of 1
- pass all stdout and stderr from the test
- pass metrics like # of database hits, etc.
- test info siloed--none commingled trace and logging.  even though five concurrent tests running, all the trace is separate.  Even threads of particular test are siloed.

ROUNDUP:
- https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2018-f68950900bc3

KNOWN BUGS:
-
 */
//GITHUB: 
//import A
A = require('./A');

//import Base
Base = require('./Base');

//import O
O = require('./O');

//import S
S = require('./S');

//import trace
trace = require('./trace');

//import Util
Util = require('./Util');

//import V
V = require('./V');

//EASY 
path = '';

testStack = [];

testList = [];

log = function() {
  return global.log.apply(this, arguments);
};

bag = Object.create({
  clear: function() {
    var k;
    for (k in bag) {
      if (k !== "clear") {
        delete bag[k];
      }
    }
  }
});

//PATTERN: target is function
target = function(cmdUNUSED_TODO) {
  var _, k, sans, v;
  if (trace.UT_BAG_DUMP) {
    //	log "HI: cmd=#{cmdUNUSED_TODO}"
    sans = Object.assign({}, bag);
    delete sans.clear;
    O.LOG(sans); //NOT-DEBUG
    if (_ = O.CNT_OWN(sans)) {
      log(`*** bag: ${_} propert${(_ === 1 ? "y" : "ies")}:`);
      for (k in sans) {
        v = sans[k];
        if (typeof v === "object") {
          log(`*** bag: ${k} =`);
          O.LOG(v);
        } else {
          log(`*** bag: ${k} = ${V.DUMP(v)}`);
        }
      }
    } else {
      log("*** bag: empty");
    }
  }
};

//PATTERN: target isn't actually proxy target
handler = { // "traps"
  get: function(target, pn) {
    //		log "read from bag: #{pn} => #{bag[pn]}"
    return bag[pn];
  },
  set: function(target, pn, pv) {
    if (trace.UT_BAG_SET) {
      //H: 	I don't know why this following line isn't green with -hl CLI
      global.log(`UT handler: set: ${pn}=${pv} <${typeof pv}>`);
    }
    if (pn === "clear") {
      throw "clear is not appropriate";
    }
    return bag[pn] = pv;
  }
};

proxyBag = new Proxy(target, handler);

UTBase = class UTBase extends Base { //@UTBase
  constructor() {
    super();
    this.const("NEG", 0);
    this.const("PROOF", 1);
    //													  FAILURE HANDLER
    this.const("FAIL_ASSERT", 1); // onAssertFail()
    this.const("FAIL_EQ", 2); // onEqFail()
    this.const("FAIL_ERROR", 3); // onError()
    this.const("FAIL_EXCEPTION", 4); // onException()
    this.const("FAIL_TIMEOUT", 5); // onTimeout()
    this.const("FAIL_UNFAIL", 6); // onUnfail()		something was supposed to fail but didn't!
    this.const("FAIL_UNEXPECTED_PROMISE", 7); // onUnexpectedPromise
    this.const("failTypes", [null, "Assert", "Eq", "Error", "Exception", "Timeout", "Unfail", "UnexpectedPromise"]);
    this.const("FM_FAILFAST", 0);
    this.const("FM_FAILTEST", 1);
    this.const("FM_RUNALL", 2);
    this.const("STAGE_SETUP", 1);
    this.const("STAGE_RUN", 2);
    this.const("STAGE_TEARDOWN", 3);
    this.const("STATE_WAITING", 1);
    this.const("STATE_RUNNING", 2);
    this.const("STATE_DONE", 3);
    this.const("WHY_ALL_TESTS_RUN", 1);
    this.const("WHY_FAIL_FAST", 2);
    this.const("WHY_FATAL", 3);
    this.const("WHY_TOLD_TO_STOP", 4);
    this.const("WHY_CLI", 5);
    this.const("whyList", [null, "ALL_TESTS_RUN", "FAIL_FAST", "FATAL", "TOLD_TO_STOP", "CLI"]);
  }

};

aGenerate = (cmd) => {
  return function(tn, fn) {
    var opts;
    if (Object.prototype.toString.call(fn) === '[object Object]') {
      opts = fn;
      fn = arguments[2];
    }
    if (typeof fn !== "function") {
      Util.abort("MISSING fn");
    }
    //		if bRunning and t_depth is 1 => @logFatal "NESTED t: the parent of '#{tn}' is also a test; change to 's' (section)"
    //		@log "found async: #{tn} --> #{@__CLASS_NAME}"
    //		@log "CLASS=#{@__CLASS_NAME}  TN=#{tn} ===> PATH=#{path}"
    //		@log "#{@__CLASS_NAME}#{path}/#{tn}"
    return new AsyncTest({
      cmd: cmd,
      cname: this.__CLASS_NAME,
      common: Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(function(mn) {
        return mn !== "constructor" && mn !== "run";
      }),
      fn: fn,
      tn: tn,
      opts: opts != null ? opts : {},
      parent: this,
      //			path: "cn=#{@__CLASS_NAME} path=(#{path}) tn=#{tn}"
      path: `${this.__CLASS_NAME} ${path}/${tn}`
    });
  };
};

testGenerate = (cmd) => {
  return function(tn, fn) {
    var opts;
    if (Object.prototype.toString.call(fn) === '[object Object]') {
      opts = fn;
      fn = arguments[2];
    }
    if (typeof fn !== "function") {
      Util.abort("MISSING fn");
    }
    return new SyncTest({
      cmd: cmd,
      cname: this.__CLASS_NAME,
      fn: fn,
      tn: tn,
      opts: opts != null ? opts : {},
      parent: this,
      path: `${this.__CLASS_NAME} ${path}/${tn}`
    });
  };
};

sectionGenerate = (cmd) => {
  return function(tn, fn) {
    var opts;
    if (typeof tn !== "string") {
      throw 0;
    }
    if (typeof fn !== "function") {
      throw 0;
    }
    if (Object.prototype.toString.call(fn) === '[object Object]') {
      opts = fn;
      fn = arguments[2];
    }
    if (typeof fn !== "function") {
      Util.abort("MISSING fn");
    }
    testStack.push(tn);
    path = testStack.join('/');
    //		log "BEG: sectionGenerate: #{path}"
    fn.bind(this)({
      opts: opts != null ? opts : {},
      parent: this, //H
      tn: tn
    });
    testStack.pop();
    return path = testStack.join('/');
  };
};

//		log "END: sectionGenerate: #{path}"
//END:UTBase

//#H: overloaded between UT runner and superclass
EXPORTED = UT = class UT extends UTBase { //@UT
  constructor(WORK_AROUND_UT_CLASS_NAME_OVERRIDE) {
    var ref;
    super();
    this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE = WORK_AROUND_UT_CLASS_NAME_OVERRIDE;
    this.__CLASS_NAME = (ref = this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE) != null ? ref : this.constructor.name;
  }

  //COMMAND: asynchronous test
  _A(a, b, c) {}

  _a(a, b, c) {}

  A(a, b, c) {
    return aGenerate('A').bind(this)(a, b, c);
  }

  a(a, b, c) {
    return aGenerate('a').bind(this)(a, b, c);
  }

  //COMMAND: asynchronous test
  _P(a, b, c) {}

  _p(a, b, c) {}

  P(a, b, c) {
    return aGenerate('P').bind(this)(a, b, c);
  }

  p(a, b, c) {
    return aGenerate('p').bind(this)(a, b, c);
  }

  //COMMAND: section / to build a hierarchy of tests
  _S(a, b, c) {}

  _s(a, b, c) {}

  S(a, b, c) {
    return sectionGenerate('S').bind(this)(a, b, c);
  }

  s(a, b, c) {
    return sectionGenerate('s').bind(this)(a, b, c);
  }

  //COMMAND: synchronous test
  _T(a, b, c) {}

  _t(a, b, c) {}

  T(a, b, c) {
    return testGenerate('T').bind(this)(a, b, c);
  }

  t(a, b, c) {
    return testGenerate('t').bind(this)(a, b, c);
  }

  static s_runner() {
    return UTRunner; //WORKAROUND: so don't have to change all the individual tests
  }

  static UTRunner() {
    return UTRunner; //WORKAROUND: so don't have to change all the individual tests   #PATTERN: not sure why can't just pass UTRunner itself (instead of function returning value)
  }

  static s_ut() {
    return new UT_UT().run();
  }

};

//END:UT
Test = class Test extends UTBase { //@Test #@test
  constructor(stuff, stuff2) {
    var _, failList_CLOSURE, k, v;
    super(); // @log "Test constructor: got stuff", stuff
    for (k in stuff) {
      v = stuff[k];
      this[k] = v;
    }
    for (k in stuff2) {
      v = stuff2[k];
      this[k] = v;
    }
    _ = this.cmd + ' ' + this.path; //		_ = "CN=#{@__CLASS_NAME} PATH=[#{@path}]"
    this.bForcePass = false;
    this.pass = 0;
    failList_CLOSURE = this.failList = [];
    this.Fail = class Fail extends UTBase { //@Fail	#@fail   #PATTERN
      constructor(mFail1, summary1, detail1, o1) {
        super();
        this.mFail = mFail1;
        this.summary = summary1;
        this.detail = detail1;
        this.o = o1;
        failList_CLOSURE.unshift(this);
        //				@log "fail constructor: mFail=#{@mFail} #{@summary} nowLen=#{failList_CLOSURE.length} ###################################################", @o
        this.bEnabled = true;
        //				console.log "RRRR=#{V.Type @o}"
        if (V.Type(this.o) === "Error") {
          //					console.log "got error"
          this.ex = this.o;
          this.o = null;
          this.stack = this.ex;
        } else {

        }
        //				https://www.stacktracejs.com
        //					console.log "console.trace():"
        //					console.trace()
        //					err = new Error @msg
        //					@stack = err.stack
        //				@log "stack", stack
        //					@log "111******************************** stack.length=#{@stack?.length}"
        //					@log "222******************************** stack.length=#{@stack?.length}", @ex
        this.DEANNA = ">>>>>>>>>>>>>> WILL BE HOME SOON";
      }

      //				O.LOG @
      //				@log "******************************** mFail=#{@mFail}"
      //				@log "******************************** summary=#{@summary}"
      //				@log "******************************** detail=#{@detail}"
      //				@log "******************************** o=#{@o}"
      //				@log "******************************** stack.length=#{@stack?.length}"
      full() {
        return Util.red(`${this.one()}\n\n${this.detail}\n${this.stack}`);
      }

      heal() {
        return this.bEnabled = false;
      }

      one() {
        return `Fail: ${this.failTypes[this.mFail]}(${this.mFail})${(this.msg ? ` ${this.msg}` : "")}: ${this.summary}`;
      }

    };
    this.one = function() {
      return `#${this.testIndex} ${_}`;
    };
    this.one2 = function() {
      return `Test: #${this.testIndex} ${_}: cmd=${this.cmd} enabled=${this.bEnabled} mState=${this.mState} mStage=${this.mStage}${(this.opts.mutex ? ` mutex=${this.opts.mutex}` : "")} pf=${this.pass}/${this.failList.length}`;
    };
    testList.unshift(this);
  }

  after(mFail, ex) {
    var EXPECT, PR, _, bFound, detail, expectMap, fail, i, j, k, kUC, l, len, m, ref, ref1, ref2;
    //		@log "#".repeat 60
    //		@log "after mFail=#{mFail}: #{@one2()}" #, ex

    //		@log "failList.length=#{@failList.length}"
    if (mFail === this.FAIL_ERROR || mFail === this.FAIL_EXCEPTION || mFail === this.FAIL_TIMEOUT || mFail === this.UNEXPECTED_PROMISE) {
      //			@log "on-the-fly append mFail to failList"
      //			@log "+ add"
      this.FAIL(mFail, null, null, ex);
    }
    //		@log "DUMP IT ALL", @failList
    expectMap = {};
    if (this.opts.expect) {
      ref = this.opts.expect.split(',');
      for (j = 0, len = ref.length; j < len; j++) {
        k = ref[j];
        kUC = k.toUpperCase();
        if (_ = this[`FAIL_${kUC}`]) {
          //					@log "after: expectMap[#{kUC}]=#{_}"
          expectMap[kUC] = _;
        } else {
          throw Error(`Invalid expect type: '${k}'`);
        }
      }
    }
//		@log()
//		@log "failList.length=#{@failList.length}"
    for (EXPECT in expectMap) {
      //			@log "EXPECT=#{EXPECT}"
      bFound = false;
      ref1 = this.failList;
      for (i = l = ref1.length - 1; l >= 0; i = l += -1) {
        fail = ref1[i];
        this.log(`--> ${fail.one()}   (compare ${this.failTypes[fail.mFail].toUpperCase()} vs ${EXPECT
        //, fail
})`);
        if (this.failTypes[fail.mFail].toUpperCase() === EXPECT) {
          //					@log "  found"
          bFound = true;
        }
      }
      if (!bFound) {
        //				@log "+ add"
        this.FAIL(this.FAIL_UNFAIL, `Expected ${EXPECT} but didn't find one`, null, null);
      }
    }
    if (this.opts.exceptionMessage != null) {
      //			@log "scanning for #{@opts.exceptionMessage}"
      bFound = false;
      ref2 = this.failList;
      for (i = m = ref2.length - 1; m >= 0; i = m += -1) {
        fail = ref2[i];
        //				@log "--> #{fail.one()}" #, fail
        if (fail.mFail === this.FAIL_EXCEPTION) {
          //					@log "found exception"
          if (fail.ex.message === (_ = this.opts.exceptionMessage)) {
            bFound = true;
            //						@log "remove because exceptionMessage match"
            this.failList.splice(i, 1);
          }
        }
      }
      if (!bFound) {
        //				@log "exceptionMessage not found"
        detail = '^' + V.COMPARE_REPORT(ex.message, _, {
          preamble: "ex.message\n\n@opts.exceptionMessage"
        });
        //				@log "+ add"
        this.FAIL(this.FAIL_ERROR, "exceptionMessage mismatch", detail, null);
      }
    }
    //H #UNSTABLE: if TWO promises, depending on the order in which they resolve... the splice may be incorrect order and will be indeterminate (WRONG) deletion
    //WORKAROUND: only have a single handler... only guaranteed to work with a single handler
    //ARCHITECTURE: or guarantee serial handler execution
    PR = new Promise((resolve, reject) => {
      var THAT, a, afterHandler, mn, n, ref3, ref4, ref5, rv;
      afterHandler = (fail) => {
        if (!fail.bEnabled) {
          //					@log "onHandler: remove i=#{i}"
          return this.failList.splice(i, 1);
        }
      };
      a = [];
      ref3 = this.failList;
      //		@log "look for onHandler"
      for (i = n = ref3.length - 1; n >= 0; i = n += -1) {
        fail = ref3[i];
        //			@log "--> #{fail.one()}" #, fail
        if (_ = this.opts[mn = `on${this.failTypes[fail.mFail]}`]) {
          //				@log "found #{mn}"
          //					@log "-----> fail", fail
          //				@log "ex", fail.ex
          //				@opts = Object.assign {}, @runner.OPTS, @runner.OPTS?.perTestOpts?[@cname], @opts, {fail:fail}
          //				@.opts = Object.assign {}, @runner.OPTS, @runner.OPTS?.perTestOpts?[@cname], @opts
          this.fail = fail;
          THAT = Object.assign({}, this, this.runner.OPTS, (ref4 = this.runner.OPTS) != null ? (ref5 = ref4.perTestOpts) != null ? ref5[this.cname] : void 0 : void 0, this.opts, {
            fail: fail // works but it's a different object
          });
          //				@log "@opts", @opts
          //				@log "@opts.fail", @opts.fail
          //				_.bind(THAT) THAT		# call onHandler																# works but it's a different object
          //				@log "calling"
          rv = _.bind(this)(this);
          if (V.type(rv) === "promise") {
            //						@log "handler returned Promise. Pushing..."
            a.push(new Promise((resolve2, reject2) => {
              return rv.then((resolved) => {
                //								@log "FOUND RESOLVED PROMISE"
                afterHandler(fail);
                return resolve2(resolved);
              }).catch((ex) => {
                //								@log "FOUND REJECTED PROMISE", ex
                afterHandler(fail);
                return reject2(ex);
              });
            }));
          } else {
            //						@log "didn't return a promise"
            afterHandler(fail);
          }
        }
      }
      if (a.length > 0) {
        //				@log "a.length > 0"
        return Promise.all(a).then(() => {
          //					@log "all array resolved"
          return resolve();
        }).catch((ex) => {
          this.logCatch("CATCH", ex);
          return reject();
        });
      } else {
        //				@log "a empty"
        return resolve();
      }
    });
    return PR.then(() => {
      var len1, len2, n, p, q, ref3, ref4, ref5, t;
      ref3 = this.failList;
      //			@log "handlers all done"
      //			@log "EXPECT2"
      for (i = n = ref3.length - 1; n >= 0; i = n += -1) {
        fail = ref3[i];
        t = this.failTypes[fail.mFail];
        //			@log t.toUpperCase()
        //			@log "--> #{fail.one()} ==> #{t}" #, fail
        if (expectMap[t.toUpperCase()]) {
          //				@log "EXPECT2: remove: i=#{i}"
          this.failList.splice(i, 1);
        }
      }
      if (this.bForcePass) {
        this.failList.length = 0;
      }
      if (this.failList.length) {
        console.log(`${this.failList.length} RESIDUAL ERRORS:`);
        ref4 = this.failList;
        // @FAIL @FAIL_TIMEOUT, "[[#{@path}]] TIMEOUT: ut.{resolve,reject} not called within #{ms}ms in asynch test"
        for (i = p = 0, len1 = ref4.length; p < len1; i = ++p) {
          fail = ref4[i];
          console.log(`#${i + 1}  ${fail.one()}`);
        }
        ref5 = this.failList;
        for (q = 0, len2 = ref5.length; q < len2; q++) {
          fail = ref5[q];
          console.log("----------------------------------------------");
          console.log(fail.full());
        }
      } else if (!this.pass) {
        //			@log "pass++"
        this.pass++;
      }
      //			@log "calling @done()"
      return this.done();
    }).catch((ex) => {
      return this.logFatal("CATCH", ex);
    });
  }

  decorate() {
    var MAKE, j, len, mn, ref;
    this.assert(this.fn, "function body is required");
    this.abort = function(msg) {
      return Util.abort(msg);
    };
    this.assert = function(b, msg) {
      var _;
      _ = msg ? `: ${msg}` : "";
      this.logSilent(`assert: b=${b}${_}`);
      if (b) {
        this.pass++;
      } else {
        this.FAIL(this.FAIL_ASSERT, `@assert${_}`, null, null);
      }
      return b;
    };
    this.bag = proxyBag;
    this.context = "CONTEXT set in decorateJustObject";
    this.defined = function(v, msg) {
      var _, b;
      _ = msg ? `: ${msg}` : "";
      this.logSilent(`defined: b=${b}${_}`);
      b = v != null;
      if (b) {
        //			log "defined"
        this.pass++;
      } else {
        this.FAIL(this.FAIL_ASSERT, _, null, null);
      }
      return b;
    };
    this.delay = function(ms) {
      var to;
      to = {
        ms: ms,
        msActual: null,
        msBeg: Date.UTC(),
        msEnd: null
      };
      return new Promise((resolve) => { //NEEEDED
        this.logg(trace.DELAY, `BEG: delay ${ms}`);
        return setTimeout(() => {
          to.msEnd = Date.UTC();
          to.msActual = to.msEnd - to.msBeg;
          this.logg(trace.DELAY_END, `END: delay ${ms} ********************************`, to);
          return resolve(to);
        }, ms);
      });
    };
    this.eq = function(a, b, msg, o) {
      var s;
      if (!(a != null) && !(b != null)) {
        this.log(`both undefined: msg=${msg}`, o);
        return true;
      }
      //			else unless V.type(a) is V.type(b)
      //				@log "bad types ((((((((((((((((((((((("
      //				s = "@eq types violation"
      a = "" + a;
      b = "" + b;
      if (!V.EQ(a, b)) {
        s = "@eq values violation";
      }
      if (s) {
        s += `\na> ${V.vt(a)}\nb> ${V.vt(b)}\n${(msg ? `MSG: ${msg}` : "")}`;
        this.FAIL(this.FAIL_EQ, `eq ${a} vs. ${b}`, `${s}\n${S.COMPARE_REPORT(a, b)}`, o);
        return false;
      } else {
        this.logSilent(`inside eq: PASS: ${msg}`, o);
        this.logSilent(V.vt(a));
        this.logSilent(V.vt(b));
        this.pass++;
        this.logSilent(`eq: pass=${this.pass}`);
        return true;
      }
    };
    this.Eq = function(a, b, msg, o) {
      var s;
      if (!(a != null) && !(b != null)) {
        this.log(`both undefined: msg=${msg}`, o);
      } else if (V.type(a) !== V.type(b)) {
        this.log("bad types (((((((((((((((((((((((");
        s = "@eq types violation";
      } else if (!V.EQ(a, b)) {
        s = "@eq values violation";
      }
      if (s) {
        s += `\na> ${V.vt(a)}\nb> ${V.vt(b)}\n${(msg ? `MSG: ${msg}` : "")}`;
        this.FAIL(this.FAIL_EQ, `eq ${a} vs. ${b}`, `${s}\n${V.COMPARE_REPORT(a, b)}`, o);
        return false;
      } else {
        this.logSilent(`inside eq: PASS: ${msg}`, o);
        this.logSilent(V.vt(a));
        this.logSilent(V.vt(b));
        this.pass++;
        this.logSilent(`eq: pass=${this.pass}`);
        return true;
      }
    };
    this.EQ = function(a, b, msg, o) {
      var s;
      if (!(a != null) && !(b != null)) {
        this.log(`both undefined: msg=${msg}`, o);
      } else if (V.Type(a) !== V.Type(b)) {
        this.log("bad types (((((((((((((((((((((((");
        s = "@eq types violation";
      } else if (!V.EQ(a, b)) {
        s = "@eq values violation";
      }
      if (s) {
        s += `\na> ${V.vt(a)}\nb> ${V.vt(b)}\n${(msg ? `MSG: ${msg}` : "")}`;
        this.FAIL(this.FAIL_EQ, `eq ${a} vs. ${b}`, `${s}\n${V.COMPARE_REPORT(a, b)}`, o);
        return false;
      } else {
        this.logSilent(`inside eq: PASS: ${msg}`, o);
        this.logSilent(V.vt(a));
        this.logSilent(V.vt(b));
        this.pass++;
        this.logSilent(`eq: pass=${this.pass}`);
        return true;
      }
    };
    this.eqfile_pr = function(a, b) { //CONVENTION
      var size_a;
      this.log(`a: ${a}`);
      this.log(`b: ${b}`);
      size_a = null;
      return this.file.fileSize(a).then((size) => {
        size_a = size;
        return this.file.fileSize(b);
      }).then((size_b) => {
        return this.eq(size_a, size_b);
      });
    };
    //			.catch (ex) =>  try commenting-out
    //				@logCatch ex
    this.ex = function(ex) {
      log("@ex: aaaaa");
      this.logCatch(ex);
      log("@ex: bbbbb");
      this.reject(ex);
      return log("@ex: ccccc");
    };
    this.FAIL = function(mFail, summary, detail, o) {
      var _, fail;
      if (!mFail) {
        throw Error("bad mFail");
      }
      //			console.log "\n\n\n"
      //			log "FAIL CALLED"
      fail = new this.Fail(mFail, summary, detail, o);
      _ = `FAIL: ${(summary ? `${summary}: ` : "")}fail=${this.failList.length}`;
      if (o) {
        this.log(_, o);
      } else {
        this.log(_);
      }
      if (this.runner.OPTS.mFailMode === this.FM_FAILFAST) {
        log(fail.full());
        this.exit(this.WHY_FAIL_FAST, summary);
        Util.abort(`FM_FAILFAST: ${_}`);
      }
      return false;
    };
    this.fatal = function(msg) {
      console.error(`fatal: ${msg}`);
      this.exit(this.WHY_FATAL, msg);
      return Util.exit(msg);
    };
    //DUP
    this.log = function() {
      if (trace.TL) {
        return Util.logBase.apply(this, [`${this.cname}/${this.tn}`, ...arguments]);
      }
    };
    MAKE = (mn, mFail) => {
      return ((mn, mFail, that) => { //PATTERN #CURRYING
        //				console.log "mn=#{mn} mFail=#{mFail}"
        return that[mn] = function(msg, o, opt) {
          //					console.log "method #{mn}: #{msg}: type=#{V.type msg}"
          if (V.type(msg) === "string") {
            return this.FAIL(mFail, msg, "", o, opt);
          } else {
            o = msg;
            opt = o;
            msg = "";
            return this.FAIL(mFail, msg, "UT~MAKE", o, opt); //H:opt
          }
        };
      })(mn, mFail, this);
    };
    MAKE("logCatch", this.FAIL_EXCEPTION);
    MAKE("logError", this.FAIL_ERROR);
    this.logSilent = function(s, o, opt) {
      return Util.logBase(this.one(), s, o, {
        bVisible: false
      });
    };
    this.logTransient = function(s, o, opt) {
      if (this.runner.OPTS.mFailMode === this.FM_RUNALL) {
        return Util.logBase(this.one(), `TRANSIENT: ${s}`, o, opt);
      } else {
        Util.logBase(this.one(), `FATAL_TRANSIENT: ${s}`, o, opt);
        return Util.exit("logError called with @mFailMode is @FM_RUNALL=false");
      }
    };
    //	@logWarning	= (s, o, opt)		->	Util.logBase @one(), "WARNING: #{s}", o, opt
    //	@logWarning	= (s, o, opt)		->	Util.logBase.apply this, [@one(), "WARNING2", arguments...]
    this.logWarning = function(s, o, opt) {
      return Util.logBase.apply(this, [this.one(), "WARNING2", ...arguments]);
    };
    this.mStage = this.STAGE_SETUP;
    this.ok = function(v) { //H #REVISIT #TEST
      //		O.LOG_DRILL this, grep:"env"
      //		@env.succ()		
      return this.resolve(v);
    };
    this.PASS = function() {
      return this.bForcePass = true;
    };
    this.throw = function(msg) {
      throw Error(msg);
    };
    //H
    //	O.LOG_DRILL @parent
    //	for v in Object.getOwnPropertyNames @parent
    //		log "==> #{v}"
    //	for k,v of @parent
    //		log "==> #{k}"
    //		if me2[k]
    //			throw "You are not allowed to define the method named '#{k}' because it clashes with a built-in property"

    //	k = "alloc"
    //	me2[k] = @parent[k]

    //		O.LOG "@parent", @common
    //H: what is this?  write test for it
    // I JUST DO NOT UNDERSTAND THIS!!!
    // in ServerStoreUT it moves alloc() to be reachable from unit test
    if (this.common) {
      ref = this.common;
      //			@log "common: #{JSON.stringify @common}"
      for (j = 0, len = ref.length; j < len; j++) {
        mn = ref[j];
        //				log "found common routine: #{mn}"
        if (this[mn]) {
          //					console.log "@common:"
          //					O.LOG @common
          throw `UT003 You are not allowed to define the method named '${mn}' because it clashes with a built-in property`;
        }
        this[mn] = this.parent[mn];
      }
    }
    return this.fn.bind(this);
  }

  // ################### end of decorate ###################
  done(who) {
    syncTestsCount--;
    //		@log "DONE DONE DONE DONE DONE: Test.done: #{@one2()}"
    Base.auditEnsureClosed();
    //		process.exit 1

    // @stack()
    this.auditMark("" + this.one2());
    if (this.mState !== this.STATE_RUNNING) {
      throw "state";
    }
    this.mState = this.STATE_DONE;
    this.msEnd = Date.UTC();
    this.msDur = this.msEnd - this.msBeg;
    //		@logg trace.UT_DUR, "dur=#{@msDur}: #{@path}"
    //		@log "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ post: who=#{who} ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

    //		if Base.openCntGet()
    //			Base.logOpenMap()
    //			@stack()
    //			Util.abort "INTERMEDIATE RESOURCES LEFT OPEN!"
    this.eventFire("test-done");
    return this.runner.testDone(this);
  }

  enable() {
    this.bEnabled = true;
    this.mStage = this.STAGE_SETUP;
    return this.mState = this.STATE_WAITING;
  }

  //		@log "enable: #{@one2()}"

  //  	delegate to runner
  eventFire(eventName, msg) {
    return this.runner.eventFire(eventName, msg != null ? msg : this.cmd, this, this.opts);
  }

  //	Test.exit
  exit(mWhy, msg) {
    return this.runner.exit(mWhy, msg);
  }

  isAsyncRunnable() {
    return false;
  }

  // 	Test.start()
  start() {
    var k, pn, pv, ref, ref1, ref2, ref3, ref4, v;
    this.opts = Object.assign({}, this.runner.OPTS, (ref = this.runner.OPTS) != null ? (ref1 = ref.perTestOpts) != null ? ref1[this.cname] : void 0 : void 0, this.opts);
    delete this.opts.perTestOpts; //H: this assumes PER TEST not PER FILE
    this.logg(trace.UT_TEST_PRE_ONE_LINER, `================== ${this.one() // /#{testList.length} #{@cname} #{@cmd}:#{@tn}#{if trace.DETAIL then ": path=#{@path}" else ""}"
}`);
    this.msBeg = Date.UTC();
    this.mState = this.STATE_RUNNING;
    syncTestsCount++;
    ref2 = this.parent;
    for (k in ref2) {
      v = ref2[k];
      this[k] = v;
    }
    ref4 = (ref3 = this.opts.decorate) != null ? ref3.test : void 0;
    for (pn in ref4) {
      pv = ref4[pn];
      //			console.log "decorate?.test: #{pn}"
      this[pn] = pv;
    }
    /*
    		testThis = Object.assign {}, @parent
    RN:
    TypeError: One of the sources for assign has an enumerable key on the prototype chain. Are you trying to assign a prototype property? We don't allow it, as this is an edge case that we do not support. This error is a performance optimization and not spec compliant.
    */
    this.fnTest = this.decorate();
    this.eventFire("test-start");
    return Base.UT_OWNER = this.one2();
  }

  //	Test.exit()		#DELEGATE
  exit(mWhy1, msg) {
    this.mWhy = mWhy1;
    log("Test.exit called");
    return this.runner.exit.apply(this.runner, arguments); //PATTERN: PROXY propagate arguments	
  }

  validate() {
    var cmd, cmds, j, k, len, ref, ref1;
    if (this.opts) {
      //			@log "opts", @opts
      if (this.opts.exceptionMessage && (this.opts.expect == null)) {
        this.opts.expect = "EXCEPTION";
      }
      cmds = ["desc", "exceptionMessage", "expect", "hang", "human", "internet", "key", "mType", "mutex", "onAssert", "onEq", "onError", "onException", "onTimeout", "onUnfail", "onUnexpectedPromise", "SO", "RUNTIME_SECS", "timeout", "url", "USER_CNT"];
      for (j = 0, len = cmds.length; j < len; j++) {
        cmd = cmds[j];
        cmds.push('_' + cmd);
      }
      for (k in this.opts) {
        if (indexOf.call(cmds, k) < 0) {
          this.logFatal(`[[${this.path}]] UT001 Unknown test option: '${k}'`, this.opts);
        }
      }
      if ((this.opts.onTimeout || this.opts.timeout) && ((ref = this.cmd) !== "_a" && ref !== "a" && ref !== "_A" && ref !== "A")) {
        this.logFatal(`[[${this.path}]] asynch opt not allowed with '${this.cmd}' cmd`, this.opts);
      }
      if (this.opts.mType != null) {
        //				@log "opts.mType=#{@opts.mType}"
        if ((0 <= (ref1 = this.opts.mType) && ref1 <= 1)) {
          return this.runner.mTypeCtrList[this.opts.mType]++;
        } else {
          return this.logFatal(`[[${this.path}]] UT002 Unknown mType=${this.opts.mType}`, this.opts);
        }
      }
    }
  }

};

//END:Test
SyncTest = class SyncTest extends Test { //@SyncTest @sync
  constructor(stuff) {
    super(stuff, {
      bSync: true,
      bWasException: false //R: move to Test and get rid of altogether
    });
  }

  
  // 	SyncTest.start()
  start() {
    var ex, rv;
    super.start();
    try {
      rv = this.fnTest(this); // SYNC
    } catch (error) {
      ex = error;
      this.log("sync had exception");
      return this.after(this.FAIL_EXCEPTION, ex);
    }
    if (Object.prototype.toString.call(rv) === "[object Promise]") { //NEEDTEST  make recoverable
      return this.after(this.FAIL_UNEXPECTED_PROMISE, rv);
    } else {
      return this.after(null, null);
    }
  }

};

AsyncTest = (function() {
  //END:SyncBase
  class AsyncTest extends Test { //@AsyncTest @async
    static s_one() {
      return `${AsyncTest.s_mutexDump()} (${AsyncTest.s_mutexCnt()})`;
    }

    static s_mutexCnt() {
      return O.CNT_OWN(AsyncTest.s_mutexMap);
    }

    static s_mutexDump() {
      return Object.getOwnPropertyNames(AsyncTest.s_mutexMap).sort().join(',');
    }

    constructor(stuff) {
      super(stuff, {
        bSync: false
      });
    }

    // 	AsyncTest.start()
    start() {
      var timer;
      super.start();
      if (this.opts.mutex) {
        AsyncTest.s_mutexMap[this.opts.mutex] = true;
      }
      timer = null;
      return new Promise((resolve1, reject1) => {
        var ex, ms, rv;
        this.resolve = resolve1;
        this.reject = reject1;
        ms = this.opts.hang ? 2147483647 : this.opts.timeout;
        //			@log "setting timer: #{ms}ms"
        timer = setTimeout(() => {
          return this.after(this.FAIL_TIMEOUT, ms); // promise is never consummated and that's okay
        }, ms);
        try {
          rv = this.fnTest(this); // ASYNC
        } catch (error) {
          ex = error;
          clearTimeout(timer);
          //				console.log ex
          //YES_CODE_PATH: I've seen this but sure why... you'd think that "catch" would be run instead
          //				throw new Error "REALLY?  I really don't see how this could be triggered!!!"  it's not a promise... it's  TRY..CATCH... that's why!
          return this.after(this.FAIL_EXCEPTION, ex);
        }
        if (this.cmd.toLowerCase() === 'p') {
          //				@log "rv=#{V.vt rv}"
          if (V.type(rv) === "promise") {
            //					@log "async test returned Promise"
            return rv.then((resolved) => {
              clearTimeout(timer);
              //						@log "FOUND RESOLVED PROMISE"
              return this.after(null, null);
            }).catch((ex) => {
              clearTimeout(timer);
              return this.after(this.FAIL_EXCEPTION, ex);
            });
          }
        }
      }).then((resolved) => {
        this.logg(trace.UT_RESOLVE_REJECT_VALUE, "RESOLVED:", resolved);
        clearTimeout(timer);
        return this.after(null, null);
      }).catch((ex) => {
        this.logg(trace.UT_RESOLVE_REJECT_VALUE, "REJECTED:", ex);
        clearTimeout(timer);
        return this.after(this.FAIL_EXCEPTION, ex);
      });
    }

    isAsyncRunnable() {
      //		O.LOG "OPTS", @runner.OPTS
      if (this.bSync) {
        //			@log "isAsyncRunnable: bSync"
        return false;
      //		else if @runner.OPTS.bSerial
      //			# force serial
      //			_ = O.EMPTY_OWN(AsyncTest.s_mutexMap)
      //#			@log "force serial: #{_}"
      //			_
      } else if (this.opts.mutex) {
        return !AsyncTest.s_mutexMap[this.opts.mutex];
      } else {
        //			@log "isAsyncRunnable: true (no mutex)"
        return true;
      }
    }

    done() {
      super.done();
      if (this.opts.mutex) {
        return delete AsyncTest.s_mutexMap[this.opts.mutex];
      }
    }

  };

  AsyncTest.s_mutexMap = {}; //STATIC

  return AsyncTest;

}).call(this);

//END:AsyncTest
Section = class Section extends Base { //@Section
  constructor() {
    super();
  }

};

//END:Section
syncTestsCount = 0; //HACK

UTRunner = class UTRunner extends UTBase { //@UTRunner @runner
  constructor(argv = ["", ""], opts1 = {}, cb = (function() {})) {
    var base, base1, ref;
    super("I DO NOT UNDERSTAND WHY I CANNOT PASS @__CLASS_NAME HERE and I don't know why it works when I don't!!!");
    this.argv = argv;
    this.opts = opts1;
    this.cb = cb;
    //		log "UT CONSTRUCTOR IMPLICIT CALL: #{@WORK_AROUND_UT_CLASS_NAME_OVERRIDE} #{@constructor.name}"
    //		O.LOG @opts
    this.OPTS = this.opts; //HACK
    if ((base = this.OPTS).bOnline == null) {
      base.bOnline = true;
    }
    if ((base1 = this.OPTS).timeout == null) {
      base1.timeout = 3000;
    }
    O.propertiesCheck(this.OPTS, "bOnline,bSerial,decorate,mFailMode,perTestOpts,timeout,userDefined");
    this.__CLASS_NAME = (ref = this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE) != null ? ref : this.constructor.name;
    //INIT
    this.bRunning = true;
    this.failList = [];
    this.mTypeCtrList = [0, 0];
    this.runningCnt = 0;
    this.pass = 0;
    this.selectList = [];
    this.thread = null;
    //MOVE
    Object.defineProperties(this, {
      TL: {
        enumerable: true,
        get: function() {
          return trace.TL;
        },
        set: function(v) {
          //					console.log "set T=#{v}"
          return trace.TL = v;
        }
      }
    });
  }

  CLI(a) {
    var CLIParser, CSV, CSV2Object, NUMBER_CSL_RE, bActed, er, getKeys, i, j, len, log_help, maybeGrabTrace, optionList, optionalNumber, parser, setTrace, sum, test, testPattern, traceList, word;
    optionList = [
      {
        o: "-a",
        d: "force all tests to be run (ignore individual test overrides)"
      },
      {
        o: "-async",
        d: "only asychronous tests"
      },
      {
        o: "-ex key1,key2,...",
        d: "exit on match"
      },
      {
        o: "-f FM#",
        d: "mFailMode: 0=run all, 1=fail at test (after possible healing), 2=fail fast (before healing)"
      },
      {
        o: "-g testPattern",
        d: "like -l (list all tests) but only show matching lines"
      },
      {
        o: "-gl key1,key2,...",
        d: "show only matching lines from log"
      },
      {
        o: "-h",
        d: "help"
      },
      {
        o: "-hl key1,key2,...",
        d: "highlight lines in log"
      },
      {
        o: "-i",
        d: "ignore test#,test#,..."
      },
      {
        o: "-kn",
        d: "exclude key1,key2,..."
      },
      {
        o: "-ky",
        d: "include key1,key2,,..."
      },
      {
        o: "-l",
        d: "list all tests"
      },
      {
        o: "-o",
        d: "offline"
      },
      {
        o: "-s",
        d: "run the tests in a serial manner, one after another"
      },
      {
        o: "-sum",
        d: "display just the summary"
      },
      {
        o: "-sync",
        d: "only sychronous tests"
      },
      {
        o: "-tl",
        d: "trace list"
      },
      {
        o: "-tg",
        d: "trace grep"
      },
      {
        o: "-tn",
        d: "trace No: turn off all trace"
      },
      {
        o: "-ty",
        d: "trace Yes: turn on all trace: naked or -ty TL,... for test logging" //DOMAIN-SPECIFIC #MOVE #H
      },
      {
        o: "<number>",
        d: "test number from 1 to the (number of tests)"
      }
    ];
    this.eventFire("CLI-optionList", optionList);
    CSV2Object = (key) => {
      var _, j, k, keys, len, ref, results;
      if (i < a.length) {
        if (/^[0-9a-zA-Z_]+(,[0-9a-zA-Z_]+)*$/.test((keys = a[i++]))) {
          
          //					@log "keys=#{keys}"
          this.OPTS[key] = _ = {};
          ref = keys.split(',');
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            k = ref[j];
            results.push(_[k.toUpperCase()] = true);
          }
          return results; //R
        } else {
          //					@log "CSV2Object @OPTS[#{key}]=", _
          return er(`UT: ${a[i - 2]}: argument isn't in correct comma-separated format: ${keys}`);
        }
      } else {
        return er(`UT: ${a[i - 1]}: must specify comma-separated keywords`);
      }
    };
    er = (msg) => {
      if (msg) {
        console.log(msg);
      }
      return this.exit(this.WHY_CLI);
    };
    
    //GITHUB: remove all trace references?
    maybeGrabTrace = (v) => {
      if (i < a.length && trace.RE.test(a[i])) {
        setTrace(a[i++], v);
        return true;
      } else {
        return false;
      }
    };
    optionalNumber = function(def) {
      if (i < a.length && /^[0-9]+$/.test(a[i])) {
        i++;
        return a[i - 1] * 1; //PATTERN
      } else {
        return def;
      }
    };
    setTrace = function(csv, v) {
      var j, k, len, ta;
      log(`FOUND TRACE CSV: ${csv} => ${v}`);
      ta = csv.split(',');
      for (j = 0, len = ta.length; j < len; j++) {
        k = ta[j];
        log(`TRACE: ${k} => ${v}`);
        if (trace[k] == null) {
          er(`trace.${k} doesn't exist`);
        }
        trace[k] = v;
      }
      return trace;
    };
    traceList = function(pattern) {
      var depth, j, k, last, len, ref;
      depth = 0;
      last = 'A';
      ref = Object.keys(trace).sort();
      for (j = 0, len = ref.length; j < len; j++) {
        k = ref[j];
        if (k[0] !== last) {
          last = k[0];
          depth++;
        }
        if (!pattern || k.includes(pattern.toUpperCase())) {
          log(`${" ".repeat(depth * 5)}${k}`);
        }
      }
      return this.exit(this.WHY_CLI);
    };
    getKeys = (bEnable) => {
      var _, j, k, keys, len, ref;
      if (i < a.length) {
        if (/^[a-zA-Z_]+(,[a-zA-Z_]+)*$/.test((keys = a[i++]))) {
          _ = {};
          ref = keys.split(',');
          for (j = 0, len = ref.length; j < len; j++) {
            k = ref[j];
            _[k.toUpperCase()] = true;
          }
          this.OPTS["keys" + bEnable] = _;
          return O.LOG(this.OPTS);
        } else {
          return er("UT: keys must be comma-delimited");
        }
      } else {
        return er("UT: missing comma-delimited set of keys");
      }
    };
    log_help = () => {
      return console.log(`node tests.js [options]\n\nOPTIONS:${S.autoTable(optionList, {
        bHeader: false
      })}`);
    };
    CSV = "testIndex,cmd,path";
    NUMBER_CSL_RE = /^\d+(,\d+)*$/;
    CLIParser = class CLIParser extends Base {};
    parser = new CLIParser();
    i = 0;
    while (i < a.length) {
      word = a[i++];
      parser.word = word;
      //			@log()
      bActed = this.eventFire("CLI-flag", parser);
      if (!bActed) {
        switch (word) {
          case "-a":
            this.OPTS.testsAll = true;
            break;
          case "-async":
            this.OPTS.bAsync = true;
            break;
          case "-f":
            this.OPTS.mFailMode = optionalNumber(1);
            break;
          case "-g":
            testPattern = a[i++];
            er(S.autoTable(testList, {
              bHeader: true,
              grep: testPattern,
              includeCSV: CSV
            }));
            break;
          case "-ex":
            CSV2Object("exitCSV");
            break;
          case "-gl": //MOVE: tests
            this.OPTS.logGrepPattern = a[i++];
            break;
          case "-h":
            er(log_help());
            break;
          case "-hl": //MOVE: tests
            CSV2Object("logHighlightPattern");
            break;
          case "-i":
            word = a[i++];
            if (NUMBER_CSL_RE.test(word)) {
              this.OPTS.testsIgnore = word;
            } else {
              er(`UT: Illegal -i parameter: "${word}".  Must be #,#,...`);
            }
            break;
          case "-kn":
            getKeys(false);
            break;
          case "-ky":
            getKeys(true);
            break;
          case "-l":
            er(S.autoTable(testList, {
              bHeader: true,
              includeCSV: CSV
            }));
            break;
          case "-o":
            this.OPTS.bOnline = false;
            break;
          case "-s":
            this.OPTS.bSerial = true;
            break;
          case "-sum":
            this.OPTS.bSummary = true;
            break;
          case "-sync":
            this.OPTS.bSync = true;
            break;
          case "-tg":
            traceList(a[i++]);
            break;
          case "-tl":
            traceList(null);
            break;
          case "-tn":
            if (!maybeGrabTrace(false)) {
              this.OPTS.traceOverride = false;
              this._T = false;
            }
            break;
          case "-ty":
            if (!maybeGrabTrace(true)) {
              this.OPTS.traceOverride = true;
              this._T = true;
            }
            break;
          default:
            if (NUMBER_CSL_RE.test(word)) {
              this.OPTS.testsInclude = word;
            } else {
              log_help();
              er(`UT: Illegal CLI option: "${word}".`);
            }
        }
      }
    }
    sum = 0;
    if (this.selectList.length > 0) {
      sum++;
    }
    if (this.OPTS.testsAll) {
      sum++;
    }
    if (this.OPTS.bAsync) {
      sum++;
    }
    if (this.OPTS.bSync) {
      sum++;
    }
    //		@log "sum=#{sum}"
    if (sum > 1) {
      er("Can't specify #, -a, -async, -sync at the same time");
    }
    if (this.OPTS.bSummary != null) {
      trace.summary();
    }
    if (this.OPTS.traceOverride != null) {
      trace.tristate(this.OPTS.traceOverride);
      trace.UT_TEST_PRE_ONE_LINER = true;
    }
    //		@log "CLI", @OPTS
    if (this.OPTS.mFailMode === this.FM_FAILFAST) {
      trace.tristate(true);
    }
    if (this.OPTS.bSerial != null) {
      for (j = 0, len = testList.length; j < len; j++) {
        test = testList[j];
        test.opts.mutex = "same";
      }
    }
  }

  count(mState) {
    var count, j, len, test;
    this.assert((0 <= mState && mState <= 2));
    count = 0;
    for (j = 0, len = testList.length; j < len; j++) {
      test = testList[j];
      if (test.mState === mState) {
        //			@log "COUNT", test
        count++;
      }
    }
    //		@log "count[#{mState}] => #{count}"
    return count;
  }

  eventFire(eventName, primative, test, opts) {
    var _opts;
    _opts = opts != null ? opts : this.OPTS;
    if (!this.bRunning && eventName !== "runner-done") {
      return;
    }
    //			console.log "shutting down is discard most events"
    this.cb(eventName, primative, test, _opts, this);
    this.onEvent(eventName, primative, test, _opts);
    switch (eventName) {
      case "CLI-optionList":
        return this.onEventCLIOptionList(primative, _opts);
      case "CLI-flag":
        return this.onEventCLIFlag(primative, _opts);
      case "left-open":
        return this.onEventLeftOpen(primative, _opts);
      case "runner-done":
        return this.onEventRunnerDone(primative, _opts);
      case "runner-start":
        return this.onEventRunnerStart(primative, _opts);
      case "test-done":
        return this.onEventTestDone(primative, test, _opts);
      case "test-start":
        return this.onEventTestStart(primative, test, _opts);
    }
  }

  //			else
  //				throw "UT004 EVENT NOT HANDLED: eventName=#{eventName}: Did subclass override methods pass all parameters to super.onEvent?"

  //	Runner.exit
  exit(mWhy1, msg) {
    var i, j, ref, s, test;
    this.mWhy = mWhy1;
    this.assert(this.mWhy != null);
    this.tassert(this.mWhy, "number");
    clearInterval(this.thread);
    this.bRunning = false;
    
    //		@log "^^^^^^^^^^^^^^^ Runner.exit: why=#{@whyList[@mWhy]}(#{@mWhy}) msg=#{msg}"
    //		@log @one()
    this.secsElapsed = Math.ceil((Date.UTC() - this.msStart) / 1000);
    if (this.pass || this.failList.length) {
      //		@log "======================================================"
      this.log(`${Base.openMsgGet()}  All unit tests completed: [${this.secsElapsed} ${S.PLURAL("second", this.secsElapsed)}] total=${this.pass + this.failList.length}: ${(!this.failList.length ? "PASS" : "pass")}=${this.pass} ${(this.failList.length ? "FAIL" : "fail")}=${this.failList.length}`);
      if (Base.openCntGet()) {
        this.eventFire("left-open");
      }
    }
    this.summary = {
      fail: this.failList.length,
      frag: this.frag = `[${this.secsElapsed}s]  pass=${this.pass} fail=${this.failList.length}`,
      mWhy: this.mWhy,
      pass: this.pass,
      why: this.whyList[this.mWhy],
      whyMsg: msg
    };
    //		@log "report.summary", @summary
    this.eventFire("runner-done", {
      mWHy: this.mWhy,
      msg: msg
    });
    if (this.failList.length) {
      this.log("calling reject");
      return this.reject(this);
    } else {
      if (trace.TRACE_DURATION_REPORT && testList.length) {
        s = `\nTests longer than ${trace.TRACE_DURATION_MIN_MS}ms:`;
        testList.sort(function(a, b) {
          if (a.msDur > b.msDur) {
            return -1;
          } else {
            return 1;
          }
        });
        for (i = j = 0, ref = testList.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          test = testList[i];
          if (test.msDur > trace.TRACE_DURATION_MIN_MS) {
            if (s) {
              log(s);
              s = null;
            }
            log(`> ${test.msDur}: ${test.tn}     ${test.path}`);
          }
        }
      }
      //			@log "Runner calling final resolve"
      return this.resolve(this);
    }
  }

  multi() {
    var s;
    s = this.one();
    return s += testList.reduce(((acc, test) => {
      if (test.mState === this.STATE_RUNNING) {
        return acc + `\nrunning >>> ${test.one2()}`;
      } else {
        return acc;
      }
    }), '');
  }

  one() {
    return `UTRunner: tests=${testList.length} enabled=${this.enabledCnt} sync=${this.syncCnt} async=${this.asyncCnt} waiting=${this.selectList.length} bRunning=${this.bRunning} running=${this.runningCnt} mutexes=${AsyncTest.s_one()}`;
  }

  //DEFAULT #OVERRIDE
  onEvent(eventName, primative, test, opts) {}

  //		@log "Runner: onEvent: #{eventName}"
  onEventCLIOptionList() {}

  onEventCLIFlag() {}

  onEventLeftOpen() {}

  onEventRunnerDone() {}

  onEventRunnerStart() {}

  onEventTestDone() {}

  onEventTestStart() {}

  run() {
    Object.defineProperties(this, {
      "@who": {
        enumerable: true,
        value: "UNIT TEST RUNNER"
      },
      msStart: {
        value: Date.UTC()
      }
    });
    return new Promise((resolve1, reject1) => {
      this.resolve = resolve1;
      this.reject = reject1;
      this.testsSort();
      this.CLI(this.argv.slice(2));
      //H: runner-done can be called without runner-start
      if (this.bRunning) {
        this.eventFire("runner-start");
        this.testsValidate();
        this.testsEnable();
        if (this.count(this.STATE_WAITING) > 0) {
          
          //				for testIndex,i in @selectList by -1
          //					if (test=testList[testIndex-1]).isAsyncRunnable()
          //						@selectList.splice i, 1
          //						@testStart test

          //HACK: utilize this timer to keep node running until all tests have completed
          return this.thread = setInterval(() => {
            //						@log "RUNNING: #{@bRunning}"
            if (this.bRunning) {
              return this.startAnotherMaybe();
            }
          }, REMOVE_ME_MS);
        } else {
          this.frag = "no tests enabled";
          return this.resolve(this);
        }
      }
    });
  }

  startAnotherMaybe() {
    var i, j, ref, results, test, testIndex;
    this.assert(this.bRunning);
    if (this.selectList.length === 0 && this.runningCnt === 0) {
      return this.exit(this.WHY_ALL_TESTS_RUN);
    } else {
      ref = this.selectList;
      //			@log "startAnotherMaybe: syncTestsCount=#{syncTestsCount}"
      results = [];
      for (i = j = ref.length - 1; j >= 0; i = j += -1) {
        testIndex = ref[i];
        if (syncTestsCount === 0) {
          test = testList[testIndex - 1];
          this.eq(test.mState, this.STATE_WAITING, "test isn't in waiting state");
          if (test.isAsyncRunnable()) { // @log "can't run '#{test.one()}' because mutex '#{test.opts.mutex}' already running"
            this.selectList.splice(i, 1);
            results.push(this.testStart(test));
          } else if (test.bSync) {
            this.selectList.splice(i, 1);
            //						@log "STARTING NEXT TEST"
            results.push(this.testStart(test));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results; //R
    }
  }

  testDone(test) {
    var _;
    this.pass += test.pass;
    this.failList = [
      ...this.failList,
      ...test.failList //PATTERN: array append
    ];
    this.runningCnt--;
    this.logg(trace.UT, `testDone: p/f=${this.pass}/${this.failList.length} concurrent=${this.runningCnt}: ${test.one()}: [${this.one()}]`);
    //		console.log "\n\n\n\nDDDDDDDDDDDDDDDDDDDDDDDDD"
    //		try
    //			throw Error "WHY"
    //		catch ex
    //			console.log ex
    //			process.exit 1

    //		console.log @stack()
    if (test.failList.length && this.OPTS.mFailMode === this.FM_FAILTEST) {
      //			@stack _="mFailMode=@FM_FAILTEST: test failure without recovery: #{test.one2()}"
      _ = `mFailMode=@FM_FAILTEST: test failure without recovery: ${test.one2()}`;
      return this.exit(this.WHY_FAIL_FAST, `${test.failList.length} error(s)`);
    } else if (this.count(this.STATE_WAITING) === 0 && this.runningCnt === 0) { //H: correct? or only let other area do it?
      return this.exit(this.WHY_ALL_TESTS_RUN);
    }
  }

  testsEnable() {
    var add, i, idx, j, l, len, len1, len2, len3, len4, len5, len6, m, n, p, q, r, ref, ref1, ref2, ref3, test, testIndex;
    this.assert(this.selectList.length === 0);
    if (testList.length > 0) {
      add = (test) => {
        return this.selectList.unshift(test.testIndex);
      };
      // 			-a always overrides capitals (if any happen to be set)
      if (this.OPTS.testsAll) {
        testList.forEach((test) => {
          return add(test);
        });
      } else if (this.OPTS.keystrue) {
        for (j = 0, len = testList.length; j < len; j++) {
          test = testList[j];
          if (O.INTERSECTION(test.keys, this.OPTS.keystrue)) {
            add(test);
          }
        }
      } else if (this.OPTS.bAsync) {
        for (l = 0, len1 = testList.length; l < len1; l++) {
          test = testList[l];
          if (/^[aA]$/.test(test.cmd)) {
            add(test);
          }
        }
      } else if (this.OPTS.bSync) {
        for (m = 0, len2 = testList.length; m < len2; m++) {
          test = testList[m];
          if (/^[tT]$/.test(test.cmd)) {
            add(test);
          }
        }
      } else if (this.OPTS.testsInclude) {
        ref = this.OPTS.testsInclude.split(',');
        for (n = 0, len3 = ref.length; n < len3; n++) {
          testIndex = ref[n];
          this.selectList.unshift(testIndex * 1); //PATTERN
        }
      } else {
        // 				override capitals
        testList.forEach((test) => {
          if (/^[A-Z]/.test(test.cmd)) {
            //						@log "found ut override: #{test.tn}"
            return add(test);
          }
        });
      }
      if (this.selectList.length === 0) {
        // 				default scenario: no CLI #, no CLI -a, no capital overrides
        testList.forEach((test) => {
          return add(test);
        });
      }
      if (this.OPTS.testsIgnore) {
        ref1 = this.OPTS.testsIgnore.split(',');
        // 				doesn't matter if default all (no capital overrides), -a, include list, or override capitals, you can always ignore specific tests
        for (p = 0, len4 = ref1.length; p < len4; p++) {
          testIndex = ref1[p];
          this.selectList = this.selectList.filter(function(i) {
            return i !== testIndex * 1;
          });
        }
      }
      //			if @OPTS.keysfalse
      //				for test in testList
      //					if O.INTERSECTION test.keys, @OPTS.keysfalse
      //						bTODO="remove from @selectList"

      //			@log "bOnline", @OPTS.bOnline
      if (!this.OPTS.bOnline) {
        //				@log "OFFLINE"
        this.selectList = this.selectList.filter((i) => {
          return !testList[i - 1].opts.internet;
        });
      }
      ref2 = this.selectList;
      for (q = 0, len5 = ref2.length; q < len5; q++) {
        i = ref2[q];
        testList[i - 1].enable();
      }
      if (0) {
        this.log("-----> VERIFY REVERSE ORDER:");
        ref3 = this.selectList;
        for (idx = r = 0, len6 = ref3.length; r < len6; idx = ++r) {
          i = ref3[idx];
          this.log(`[${idx}] -----> ${i} -> ${testList[i - 1].one2()}`);
        }
      }
      this.enabledCnt = testList.reduce((function(acc, test) {
        if (test.bEnabled) {
          return acc + 1;
        } else {
          return acc;
        }
      }), 0);
      this.syncCnt = testList.reduce((function(acc, test) {
        if (test.bEnabled && test.bSync) {
          return acc + 1;
        } else {
          return acc;
        }
      }), 0);
      this.asyncCnt = testList.reduce((function(acc, test) {
        if (test.bEnabled && !test.bSync) {
          return acc + 1;
        } else {
          return acc;
        }
      }), 0);
      return this.log(`${this.summary} Found ${testList.length} ${S.PLURAL("test", testList.length)}${(this.enabledCnt < testList.length ? ` with ${this.enabledCnt} enabled` : "")}`);
    }
  }

  testsSort() {
    var _, i, j, len, results, test, testIndex;
    testList.reverse(); //IMPORTANT: testList must be in reverse order so that we can splice way elements and not break our iterators
    _ = [];
    testList.forEach((test) => {
      if (!test.bSync) {
        return _.push(test);
      }
    });
    testList.forEach((test) => {
      if (test.bSync) {
        return _.push(test);
      }
    });
    testList = _;
    testIndex = 1;
    results = [];
    for (i = j = 0, len = testList.length; j < len; i = ++j) {
      test = testList[i];
      test.testIndex = testIndex++;
      test.runner = this;
      test.bEnabled = false;
      test.mStage = this.STAGE_SETUP;
      test.mState = this.DISABLED;
      results.push(test.testMutex != null ? test.testMutex : test.testMutex = '');
    }
    return results; //R
  }

  //			@log "[#{i}] pre: #{test.one()}"
  testStart(test) {
    this.runningCnt++;
    //		@log "&&&&& testStart: concurrent now=#{@runningCnt}: #{test.one()}"
    return test.start();
  }

  testsValidate() {
    var j, len, test;
    for (j = 0, len = testList.length; j < len; j++) {
      test = testList[j];
      test.validate();
    }
    return this.summary = `[NEG=${this.mTypeCtrList[0]} PROOF=${this.mTypeCtrList[1]}]`;
  }

};

//END:UTRunner

// exceptionMessage:"",
UT_UT = class UT_UT extends UT { //@UT_UT		@unittest  @ut
  run() {
    this.s("top", function() {
      this.t("test1", function() {});
      return this.t("test2", function() {});
    });
    this.s("top", function() {
      return this.s("middle", function() {
        this.t("test1", function() {});
        return this.t("test2", function() {});
      });
    });
    //COMMENTED-OUT
    //		@t "UT events", (ut) ->
    //			@testHub.startClient "/tmp/ut/UT_UT"
    //			.then (client) =>
    //				@log "one: #{client.one()}"
    //			.catch (ex) =>
    //				@logCatch "startClient", ex		#H: logCatch WHAT should be the parameter?
    this.t("opts", function(ut) {
      this.human("ut.opts", ut.opts);
      this.eq(ut.opts.aaa, "AAA");
      this.log("@opts=", this.opts);
      //			@log "bbb"
      this.eq(this.opts.aaa, "AAA");
      return this.eq(this.get42(), 42);
    });
    this.s("bag", function() {
      this.t("set", function() {
        this.bag();
        this.bag.color = "red";
        return this.bag();
      });
      this.t("get", function() {
        this.bag();
        this.eq(this.bag.color, "red");
        this.bag.clear();
        this.eq(this.bag.color, void 0);
        return this.bag();
      });
      return this.t("clear invalid", function() {
        var ex;
        try {
          this.bag.clear = "this should fail";
          return this.FAIL(this.FAIL_ERROR, "it's illegal to assign 'clear' to bag", "", this.bag);
        } catch (error) {
          ex = error;
          return this.PASS();
        }
      });
    });
    this.s("sync nesting test", function() {
      //			@log "SYNC"
      //			t = 0
      //			@log "div 0"
      //			t = t / t
      //			O.LOG this
      //			@log "hello"
      return this.s("a", (ut) => {
        //				@log "section log"
        //				@logError "section logError"
        //				@logCatch "section logCatch"
        this.s("b1", function(ut) {
          this.t("b1c1", function(ut) {});
          //						@log "test log"
          //						@logError "test logError"
          //						@logCatch "test logCatch"
          return this.t("b1c2", function(ut) {});
        });
        return this.s("b2", function(ut) {
          return this.s("b2c1", function(ut) {
            return this.t("b2c1d1", function(ut) {});
          });
        });
      });
    });
    this.s("async nesting test", function(ut) {
      return this.s("a", function(ut) {
        this.s("b1", function(ut) {
          this.a("b1c1", function(ut) {
            return setTimeout((() => {
              return ut.resolve();
            }), 10);
          });
          //						@log "setTimeout"
          //						@log "asynch log"
          //						@logError "asynch logError"
          //						@logCatch "asynch logCatch"
          return this.a("b1c2", function(ut) {
            return ut.resolve();
          });
        });
        return this.s("b2", function(ut) {
          return this.s("b2c1", function(ut) {
            return this.a("b2c1d1", function(ut) {
              return ut.resolve();
            });
          });
        });
      });
    });
    this.s("options", function() {
      this.s("general", function() {
        return this.t("commented out", {
          _desc: "this is not used"
        }, function() {});
      });
      return this.s("specific", function() {
        this.t("exceptionMessage", {
          exceptionMessage: "Deanna is beautiful"
        }, function() {
          throw Error("Deanna is beautiful");
        });
        this.s("expect", function() {
          this.s("assert", function() {
            this.t("pos", function() {
              return this.assert(true, "Saturday");
            });
            return this.t("neg", {
              expect: "ASSERT",
              mType: this.NEG
            }, function() {
              return this.assert(false, "Sunday");
            });
          });
          this._t("bManual: fatal", {
            comment: "can't test because it exits node",
            bManual: true
          }, function() {
            //						TODO: skip if bManual is true
            this.fatal();
            return this.fatal("display me on console");
          });
          return this.a("promise timeout", {
            timeout: 10,
            expect: "TIMEOUT",
            mType: this.NEG
          }, function(ut) {});
        });
        //						DO NOT CALL ut.resolve()
        this.a("onTimeout", {
          timeout: 10,
          onTimeout: function(ut) {
            //							@log "opts", ut.opts			#MOST-BIZARRE BUG EVER!  the get: property of ut was opening connection:
            //__76  >                                   ∟ user: ut
            //__77  40:58 [TestHub] open ut
            //__78  40:58 [TestHub] auditOpen SQL-ut: count=1
            this.log("fail", ut.fail);
            this.log(`onTimeout called: ${ut.opts.timeout}=${this.opts.timeout}`);
            return ut.fail.heal();
          }
        }, function(ut) {
          return this.log("do not call ut.resolve to force timeout");
        });
        this.a("timeout", {
          timeout: 1000
        }, function(ut) {
          //					@log "opts parameter"
          //					O.LOG ut.opts
          this.eq(ut.opts.timeout, 1000);
          return ut.resolve();
        });
        return this._t("seek exception but don't get one", {
          bManual: true,
          expect: "EXCEPTION",
          mType: this.NEG
        }, function() {
          return this.log("hello");
        });
      });
    });
    this.s("eq", function() {
      //UT: two pass
      //UT: two fail
      //UT: third parameter description supported
      this.t("single parameter", {
        expect: "EQ,EQ",
        onEq: function(fail) {
          return this.log("inside onEq @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
        }
      }, function() {        //					fail.heal()
        this.eq(1, 2);
        this.eq("only passed one parameter");
        return this.eq(1, 2);
      });
      this.t("differing types (loose)", {
        desc: "@eq is NOT strict, i.e., it checks VALUE only (string vs. integer is okay and passes"
      }, function() {
        return this.eq("5", 5);
      });
      this.t("differing types (kinda POS)", {
        desc: "@Eq is kinda strict, i.e., it checks VALUE only (string vs. string is okay and passes"
      }, function() {
        return this.Eq("peter", "peter");
      });
      this.t("differing types (kinda NEG)", {
        expect: "EQ",
        desc: "@Eq is kinda strict",
        mType: this.NEG
      }, function() {
        return this.Eq("5", 5);
      });
      this.t("differing types (strict POS)", {}, function() {
        return this.EQ(new String("peter"), new String("peter"));
      });
      return this.t("differing types (strict NEG)", {
        expect: "EQ",
        desc: "@EQ is strict!, i.e., VALUE and TYPE must agree!",
        mType: this.NEG
      }, function() {
        return this.EQ("peter", new String("peter"));
      });
    });
    this.a("@delay", function(ut) {
      this.log("before");
      this.delay(50).then((to) => {
        this.log("timed out", to);
        return ut.resolve(to);
      }).catch((ex) => {
        this.log("catch");
        return this.logCatch("CATCH", ex);
      });
      return this.log("after");
    });
    this.s("logging", function() {
      this.t("log no arguments", function() {
        if (trace.HUMAN) {
          this["log"]();
          return this["log"]();
        }
      });
      this.t("logCatch", {
        expect: "EXCEPTION"
      }, function() {
        return this.logCatch("this is logCatch");
      });
      return this.t("logError", {
        expect: "ERROR"
      }, function() {
        return this.logError("this is logError");
      });
    });
    this.t("one", function(ut) {
      this.human(this.one());
      return this.human(this.one2());
    });
    this.s("misc", function() {});
    //			@A "don't close", (ut) ->
    //				@log "something doesn't stop"
    this.a("mutex", {
      mutex: "J"
    }, function(ut) {
      this.log("inside MUTEX");
      return ut.resolve();
    });
    this.a("parallel 1", {
      mutex: "P1"
    }, function(ut) {
      this.log("P1: before");
      return this.delay(1000).then(() => {
        this.log("P1: after");
        return ut.resolve();
      });
    });
    this.a("parallel 2", {
      mutex: "P2"
    }, function(ut) {
      this.log("P2: before");
      return this.delay(1000).then(() => {
        this.log("P2: after");
        return ut.resolve();
      });
    });
    this.a("mutex1", {
      mutex: "orange"
    }, function(ut) {
      this.log("M1: before");
      return this.delay(1000).then(() => {
        this.log("M1: after");
        return ut.resolve();
      });
    });
    this.a("mutex2", {
      mutex: "orange"
    }, function(ut) {
      this.log("M2: before");
      return this.delay(1000).then(() => {
        this.log("M2: after");
        return ut.resolve();
      });
    });
    this.s("async return implicit Promise", function() {
      this.p("resolved", function() {
        return new Promise((resolve, reject) => {
          return resolve("I am good");
        });
      });
      return this.p("rejected", {
        expect: "EXCEPTION",
        mType: this.NEG
      }, function() {
        return new Promise((resolve, reject) => {
          return reject("I am bad");
        });
      });
    });
    return this.t("trace.T", function() {
      var keep;
      keep = this.runner.TL;
      this.runner.TL = 55;
      this.eq(this.runner.TL, 55);
      //			@log "yes show"	#, @trace
      this.runner.TL = false;
      this.eq(this.runner.TL, false);
      //			@log "no show"	#, @trace
      return this.runner.TL = keep;
    });
  }

};

//		@t "clash with built-in", {mType:@NEG}, (ut) ->
//			@log "clash"
//			O.LOG_DRILL this
//			@delay = 10			
//END:UT_UT
module.exports = EXPORTED;
