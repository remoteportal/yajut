// Generated by CoffeeScript 2.3.0
var A, Base, INFINITE_LOOP_DETECTION_ITERATIONS, O, UT, UTUT, V, bRan, bRunning, bag, decorate, fail, fs, handler, iterations, msStart, pass, path, proxyBag, t_depth, target, testIndex, testList, testListSaved, testStack, trace, util;

INFINITE_LOOP_DETECTION_ITERATIONS = 100;

//if node
fs = require('fs');

A = require('./A');

Base = require('./Base');

O = require('./O');

util = require('./Util');

trace = require('./trace');

V = require('./V');

//TODO
// - make capital to only run THAT test
// - ut() to fulfill async?
// - force to run all tests
// - create UT and UTRunner as they *are* different, right?
// - decorate section (s)
// - log EVERY run to new timestamp directory with tests ran in the directory name... store ALL data
// 		- two files: currently enabled trace and ALL TRACE
//		- auto-zip at end
//		- directory: 2018-05-01 6m tot=89 P_88 F_1 3-TestClient,Store,DeathStar TR=UT_TEST_POST_ONE_LINER,ID_TRANSLATE.zip
//			traceSelected.txt
//			traceAll.txt
//			src/...
// - if run all TESTS report how many are disabled _
path = '';

testStack = [];

testList = [];

testIndex = null;

bRunning = null;

iterations = null;

testListSaved = null;

t_depth = 0;

pass = fail = 0;

bRan = false;

msStart = null;

bag = Object.create({
  clear: function() {
    var k;
    for (k in bag) {
      if (k !== "clear") {
        delete bag[k];
      }
    }
  }
});

target = function(cmdUNUSED_TODO) {
  var _, k, sans, v;
  if (trace.UT_BAG_DUMP) {
    //	console.log "HI: cmd=#{cmdUNUSED_TODO}"
    sans = Object.assign({}, bag);
    delete sans.clear;
    O.DUMP(sans); //NOT-DEBUG
    if (_ = O.CNT_OWN(sans)) {
      console.log(`*** bag: ${_} propert${(_ === 1 ? "y" : "ies")}:`);
      for (k in sans) {
        v = sans[k];
        console.log(`*** bag: ${k} = ${V.DUMP(v)}`);
      }
    } else {
      console.log("*** bag: empty");
    }
  }
};

handler = { // "traps"
  get: function(target, pn) {
    return bag[pn];
  },
  set: function(target, pn, pv) {
    if (trace.UT_BAG_SET) {
      console.log(`proxy: set: ${pn}=${pv} <${typeof pv}>`);
    }
    if (pn === "clear") {
      throw "clear is not appropriate";
    }
    return bag[pn] = pv;
  }
};

proxyBag = new Proxy(target, handler);

decorate = function(test, objectThis) {
  var fn2, me2;
  me2 = Object.create(objectThis);
  me2.bag = proxyBag;
  me2.context = "CONTEXT";
  me2.eq = function() {
    var _, i, j, ref;
    //		@log "inside eq"
    if (arguments.length) {
      //			@log "arguments passed: arguments.length=#{arguments.length}"
      _ = arguments[0];
      if (!(arguments[0] != null) && !(arguments[1] != null)) {
        return;
      }
//H: these lines cause a hang!
//			throw "FORCED THROW: eq failure" if arguments[0] isnt arguments[1]
//				@log "both undefined"
      for (i = j = 0, ref = arguments.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
        //				@log "arg#{i}: #{arguments[i]}"

        //WARNING: sometimes hangs node
        if (_ !== arguments[i]) {
          this.logError(`${_}`);
          this.logError(`${arguments[i]}`);
        }
      }
    }
  };
  //										throw "eq fail"
  //		@log "eq: done: args=#{arguments.length}"
  me2.fail = function(msg) {
    fail++;
    if (msg) {
      return this.logError(msg);
    }
  };
  //DUP
  me2.log = (s, o, opt) => {
    if (trace.UT_TEST_LOG_ENABLED) {
      return util.logBase(`${test.cname} - ${test.tn}`, s, o, opt);
    }
  };
  me2.logError = (s, o, opt) => {
    if (this.bRunToCompletion) {
      return util.logBase(`${test.cname} - ${test.tn}`, `ERROR: ${s}`, o, opt);
    } else {
      util.logBase(`${test.cname} - ${test.tn}`, `FATAL_ERROR: ${s}`, o, opt);
      //if node
      return process.exit(1);
    }
  };
  //endif
  me2.logCatch = (s, o, opt) => {
    if (this.bRunToCompletion) {
      return util.logBase(`${test.cname} - ${test.tn}`, `CATCH: ${s}`, o, opt);
    } else {
      util.logBase(`${test.cname} - ${test.tn}`, `FATAL_CATCH: ${s}`, o, opt);
      //if node
      return process.exit(1);
    }
  };
  //endif
  me2.logFatal = (s, o, opt) => {
    util.logBase(`${test.cname} - ${test.tn}`, `FATAL: ${s}`, o, opt);
    //if node
    return process.exit(1);
  };
  //endif
  me2.logWarning = (s, o, opt) => {
    return util.logBase(`${test.cname} - ${test.tn}`, `WARNING: ${s}`, o, opt);
  };
  me2.pass = function() {
    return pass++;
  };
  return fn2 = test.fn.bind(me2);
};

module.exports = UT = class UT extends Base {
  constructor(bRunToCompletion, fnCallback) {
    super("I DO NOT UNDERSTAND WHY I CANNOT PASS @name HERE and I don't know why it works when I don't!!!");
    this.bRunToCompletion = bRunToCompletion;
    this.fnCallback = fnCallback;
    //		@log "@@@@ #{constructor.name}"	# Object
    //		@log "@@@@ #{@constructor.name}"	# Object
    //		@log "name=#{@name}"
    // @log "bRunToCompletion=#{@bRunToCompletion} HELP"
    this.name = this.constructor.name; //+ "(UT)"			#H: @name is way to common #RENAME
    testIndex = "pre";
    bRunning = false;
  }

  //COMMAND: asynchronous test
  _a(tn, fn) {}

  a(tn, fn) {
    if (bRunning && t_depth === 1) {
      this.logFatal(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
    }
    //		@log "found async: #{tn} --> #{@name}"
    return testList.unshift({
      cmd: 'a',
      cname: this.name,
      tn: tn,
      fn: fn,
      path: path
    });
  }

  //COMMAND: section / directory of tests
  _s(tn, fn) {}

  s(tn, fn) {
    if (typeof tn !== "string") {
      throw 0;
    }
    if (typeof fn !== "function") {
      throw 0;
    }
    if (bRunning && t_depth === 1) {
      this.logFatal(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
    }
    //		@log "found section: #{tn}"
    testStack.push(tn);
    path = '/' + testStack.join('/');
    testList.unshift({
      cmd: 's',
      cname: this.name,
      tn: tn,
      fn: fn,
      path: path
    });
    //		fn
    //			tn: tn
    fn.bind(this)({
      tn: tn
    });
    return testStack.pop();
  }

  //COMMAND: synchronous test
  _t(tn, fn) {}

  t(tn, fn) {
    if (bRunning) {
      if (++t_depth === 2) {
        this.logFatal(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
      }
      fn();
      return --t_depth;
    } else {
      //			@log "found test: #{tn}"
      return testList.unshift({
        cmd: 't',
        cname: this.name,
        tn: tn,
        fn: fn,
        path: path
      });
    }
  }

  next() {
    var ex, fnBoundObjectThis, objectThis, passSave, pr, test, utParameter;
    objectThis = this;
    //H: is this while loop even used anymore?
    while (testIndex < testList.length) {
      if (iterations++ > INFINITE_LOOP_DETECTION_ITERATIONS) {
        this.logFatal(`infinite loop detected (stopped at ${iterations} iterations)`);
      }
      //			@log "#{testListSaved} VS #{testList.length}"
      if (testListSaved !== testList.length) {
        this.logFatal("testList corruption");
      }
      test = testList[testIndex];
      if (trace.UT_TEST_PRE_ONE_LINER) {
        // iter=#{iterations}
        this.log(`RUN: #${testIndex + 1}/${testList.length} ${test.cmd}:${test.tn}${(trace.DETAIL ? `: ${test.path}` : "")}`);
      }
      if (test.bRun) {
        this.logFatal("already run!");
      }
      test.bRun = true;
      switch (test.cmd) {
        case 'a':
          pr = new Promise((resolve, reject) => {
            var ex, fn2;
            //						@log "ASYNC #{test.tn} PATH=#{test.path}"	# type=#{typeof test.fn} fn=#{test.fn}"
            fn2 = decorate(test, objectThis);
            try {
              return fn2({
                tn: test.tn,
                resolve: resolve,
                reject: reject
              });
            } catch (error) {
              ex = error;
              util.logBase(`ut-a CATCH from ${test.cname} - ${test.tn}`, ex);
              return process.exit(1);
            }
          }).then(() => {
            pass++;
            return this.post("a-then");
          }).catch((ex) => {
            fail++;
            this.logFatal("a", ex);
            return this.post("a-catch"); //IMPORTANT
          });
          return;
        case 't':
          //					@log "RUNNING #{test.tn} PATH=#{test.path}"#" #{test.fn}"
          passSave = pass;
          try {
            if (++t_depth === 2) {
              this.logFatal("nested tests");
            }
            utParameter = {
              tn: test.tn
            };
            if (typeof this.fnCallback === "function") {
              this.fnCallback("pre", "t", utParameter, objectThis);
            }
            fnBoundObjectThis = decorate(test, objectThis);
            fnBoundObjectThis(utParameter);
            if (typeof this.fnCallback === "function") {
              this.fnCallback("post", "t", utParameter, objectThis);
            }
            if (trace.UT_TEST_POST_ONE_LINER) { //TODO
              this.log("say something meaningful here");
            }
            if (pass === passSave) {
              // implicit pass
              pass++;
            }
            --t_depth;
            this.post("t"); //WARNING: could cause very deep stack
          } catch (error) {
            ex = error;
            fail++;
            this.logFatal("in test (t) handler: b-bind", ex);
            this.post("t-catch");
          }
          return;
        //					@log "back"
        case 's':
          //					@log "here1"
          this.post("s");
          return;
        default:
          //					@log "here2"
          this.logFatal(`unknown cmd=${test.cmd}`);
      }
    }
  }

  //			@log "bottom of while"
  //		@log "UT-DONE ##{testIndex}/#{testList.length}"
  post(who) {
    if (++testIndex === testList.length) {
      //			@log "UT-DONE: who=#{who}"
      return bRunning = false;
    } else {
      //			@log "post: next: who=#{who}"
      return this.next();
    }
  }

  run(testHub1) { //H: UT should know NOTHING about "TestHub"
    this.testHub = testHub1;
    return new Promise((resolve, reject) => {
      var test, timer;
      if (bRunning) {
        throw 0;
      }
      if (bRan) {
        throw 0;
      }
      bRan = true;
      msStart = Date.now();
      //			@log "run: test count=#{testList.length} CLOUD=#{@testHub.c.CLOUD}"
      if (testList.length > 0) {
        testList.reverse();
        testIndex = 0;
        while (testIndex < testList.length) {
          test = testList[testIndex];
          //				@log "pre: ##{testIndex} #{test.cmd}:#{test.tn}: #{test.path}"
          testIndex++;
        }
        //			@log "@@@@@@@@@@@@@@@@@"
        //			@log "------------------------------------"
        testIndex = 0;
        bRunning = true;
        iterations = 0;
        testListSaved = testList.length;
        this.next();
        //HACK: utilize this timer to keep node running until all tests have completed
        return timer = setInterval(() => {
          var secs;
          //					@log "ping"
          if (!bRunning) {
            secs = Math.ceil((Date.now() - msStart) / 1000);
            this.log(`all unit tests completed: [${secs} second${(secs === 1 ? "" : "s")}] total=${pass + fail}: ${(!fail ? "PASS" : "pass")}=${pass} ${(fail ? "FAIL" : "fail")}=${fail}`);
            clearInterval(timer);
            return resolve();
          }
        }, 100);
      }
    });
  }

  //if ut
  ut(testHub) {
    //		@log "CLOUD=#{testHub.c.CLOUD}"
    return new UTUT().run(testHub);
  }

};

//endif
UTUT = class UTUT extends UT {
  run() {
    this.t("UT events", function(ut) {
      //			@log "say hi: #{ut.say_hi_to_peter}"
      this.eq(ut.say_hi_to_peter, "Hi Pete!");
      //			.then (client) =>
      //				@log "one: #{client.one}"
      return this.testHub.startClient("spaceName HELP").catch((ex) => {
        return this.logCatch("startClient2", ex); //H: logCatch WHAT should be the parameter?
      });
    });
    this.s("bag", function() {
      this.t("set", function() {
        this.bag();
        this.bag.color = "red";
        return this.bag();
      });
      this.t("get", function() {
        this.bag();
        this.eq(this.bag.color, "red");
        this.bag.clear();
        this.eq(this.bag.color, void 0);
        return this.bag();
      });
      return this.t("clear invalid", function() {
        var ex;
        try {
          this.bag.clear = "this should fail";
          return this.fail("it's illegal to assign 'clear' to bag");
        } catch (error) {
          ex = error;
          return this.pass();
        }
      });
    });
    this.s("sync nesting test", function() {
      //			@log "SYNC"
      //			t = 0
      //			@log "div 0"
      //			t = t / t
      //			O.DUMP this
      //			@log "hello"
      return this.s("a", (ut) => {
        //				@log "section log"
        //				@logError "section logError"
        //				@logCatch "section logCatch"
        this.s("b1", function(ut) {
          this.t("b1c1", function(ut) {});
          //						@log "test log"
          //						@logError "test logError"
          //						@logCatch "test logCatch"
          return this.t("b1c2", function(ut) {});
        });
        return this.s("b2", function(ut) {
          return this.s("b2c1", function(ut) {
            return this.t("b2c1d1", function(ut) {});
          });
        });
      });
    });
    return this.s("async nesting test", function(ut) {
      return this.s("a", function(ut) {
        this.s("b1", function(ut) {
          this.a("b1c1", function(ut) {
            return setTimeout((() => {
              return ut.resolve();
            }), 3000);
          });
          //						@log "setTimeout"
          //						@log "asynch log"
          //						@logError "asynch logError"
          //						@logCatch "asynch logCatch"
          return this.a("b1c2", function(ut) {
            return ut.resolve();
          });
        });
        return this.s("b2", function(ut) {
          return this.s("b2c1", function(ut) {
            return this.a("b2c1d1", function(ut) {
              return ut.resolve();
            });
          });
        });
      });
    });
  }

};

//endif
