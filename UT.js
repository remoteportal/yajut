// Generated by CoffeeScript 2.3.0
var A, Base, INFINITE_LOOP_DETECTION_ITERATIONS, O, UT, UTUT, V, aGenerate, bHappy, bRan, bRunning, bag, decorate, decorateJustObject, fail, fs, g_timer, handler, iterations, msStart, pass, path, proxyBag, sectionGenerate, t_depth, target, testGenerate, testIndex, testList, testListSaved, testStack, trace, util;

INFINITE_LOOP_DETECTION_ITERATIONS = 100;

/*			**MASTER**
YAJUT - Yet Another Javascript Unit Test

EXTENDS: Base

b
Promise-based, hierarchical test, minimalist and least-boilerplate, inline with source code unit test framework.

- (ut) -> vs @utMethod: the value of 'ut' parameter is that:
    - @ form is shorter
    - but using ut: a test can use closure not fat arrows (=>) to access ut properties and methods
    - but using ut: if inside a overridden child method of a sub-class: onReceive where 'this' context is the object not the ut

FEATURES
-

TODOs
- ut() to fulfill async?
- force to run all tests
- create UT and UTRunner as they *are* different, right?
- decorate section (s)
- log EVERY run to new timestamp directory with tests ran in the directory name... store ALL data
	- two files: currently enabled trace and ALL TRACE
	- auto-zip at end
	- directory: 2018-05-01 6m tot=89 P_88 F_1 3-TestClient,Store,DeathStar TR=UT_TEST_POST_ONE_LINER,ID_TRANSLATE.zip
		traceSelected.txt
		traceAll.txt
		src/...
- if run all TESTS report how many are disabled _
- change ut to t
- target=NODE_SERVER command line switch
- put cleanup in opts  but that means @client and @server or implement our own timeout mechanism, again, inside here:
- onPost -> @testHub.directoryRemoveRecursiveForce()
- actually:  @testHub.directoryGetTempInstanceSpace
- test auto-discovery so don't need to explicity list in tests.coffee
- add @rnd() functions
- add milepost functionality
- validate system-level options parameter names
- validate per-unit test on-the-fly options for mispellings

KNOWN BUGS:
-
*/
//if node
fs = require('fs');

A = require('./A');

Base = require('./Base');

O = require('./O');

trace = require('./trace');

util = require('./Util');

V = require('./V');

bHappy = true;

g_timer = null;

path = '';

testStack = [];

testList = [];

testIndex = null;

bRunning = null;

iterations = null;

testListSaved = null;

t_depth = 0;

pass = fail = 0;

bRan = false;

msStart = null;

bag = Object.create({
  clear: function() {
    var k;
    for (k in bag) {
      if (k !== "clear") {
        delete bag[k];
      }
    }
  }
});

target = function(cmdUNUSED_TODO) {
  var _, k, sans, v;
  if (trace.UT_BAG_DUMP) {
    //	console.log "HI: cmd=#{cmdUNUSED_TODO}"
    sans = Object.assign({}, bag);
    delete sans.clear;
    O.LOG(sans); //NOT-DEBUG
    if (_ = O.CNT_OWN(sans)) {
      console.log(`*** bag: ${_} propert${(_ === 1 ? "y" : "ies")}:`);
      for (k in sans) {
        v = sans[k];
        console.log(`*** bag: ${k} = ${V.DUMP(v)}`);
      }
    } else {
      console.log("*** bag: empty");
    }
  }
};

handler = { // "traps"
  get: function(target, pn) {
    return bag[pn];
  },
  set: function(target, pn, pv) {
    if (trace.UT_BAG_SET) {
      console.log(`proxy: set: ${pn}=${pv} <${typeof pv}>`);
    }
    if (pn === "clear") {
      throw "clear is not appropriate";
    }
    return bag[pn] = pv;
  }
};

proxyBag = new Proxy(target, handler);

decorate = function(test, fn, objectThis) {
  var fn2, me2;
  if (!fn) {
    console.error(`${test.tn}: function body is required`);
    //if node
    process.exit(1);
  }
  //endif
  me2 = Object.create(objectThis);
  decorateJustObject(test, me2);
  //	console.log "*** bRunToCompletion=#{me2.bRunToCompletion}"
  return fn2 = fn.bind(me2);
};

decorateJustObject = function(test, me2) {
  me2.tn = test.tn;
  me2.opts = test.opts;
  me2.bag = proxyBag;
  me2.context = "CONTEXT set in decorateJustObject";
  //METHODS
  me2.assert = function(b, msg) {
    var _;
    _ = msg ? `: ${msg}` : "";
    this.logSilent(`assert: b=${b}${_}`);
    if (b) {
      pass++;
    } else {
      this.log(`ASSERTION FAILURE${_}`);
      fail++;
    }
    return b;
  };
  //TODO: create V.EQ routine
  me2.eq = function() {
    var _, bEQ, i, j, l, m, n, ref, ref1, ref2, ref3, s;
    bEQ = true;
    this.logSilent(`inside eq: arguments.length=${arguments.length}`);
    //		@log "ut: bRunToCompletion=#{@bRunToCompletion}"
    if (arguments.length >= 2) {
      this.logSilent(`arguments passed: arguments.length=${arguments.length}`);
      if (!(arguments[0] != null) && !(arguments[1] != null)) {
        this.logSilent("both undefined");
        return;
      }
      // TYPES
      bEQ = true;
      _ = V.TYPE(arguments[0]);
      for (i = j = 0, ref = arguments.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
        this.logSilent(`arg${i}: ${V.PAIR(arguments[i])} ${typeof arguments[i]}`);
        if (_ !== V.TYPE(arguments[i])) {
          bEQ = false;
        }
      }
      if (!bEQ) {
        s = "@eq types violation:\n";
        for (i = l = 0, ref1 = arguments.length - 1; (0 <= ref1 ? l <= ref1 : l >= ref1); i = 0 <= ref1 ? ++l : --l) {
          s += `> arg${i}: ${V.TYPE(arguments[i])}\n`;
        }
        //				@log "ut2: bRunToCompletion=#{@bRunToCompletion}"
        this.logError(s);
      }
      if (bEQ) {
        // VALUES
        bEQ = true;
        _ = arguments[0];
        for (i = m = 0, ref2 = arguments.length - 1; (0 <= ref2 ? m <= ref2 : m >= ref2); i = 0 <= ref2 ? ++m : --m) {
          this.logSilent(`arg${i}: ${V.PAIR(arguments[i])} ${typeof arguments[i]}`);
          //WARNING: old code used to sometime hang node; it was very bizarre
          if (_ !== arguments[i]) {
            bEQ = false;
          }
        }
        if (!bEQ) {
          s = "@eq values violation:\n";
//H: these lines cause a hang!
          for (i = n = 0, ref3 = arguments.length - 1; (0 <= ref3 ? n <= ref3 : n >= ref3); i = 0 <= ref3 ? ++n : --n) {
            s += `> arg${i}: ${V.PAIR(arguments[i])}\n`;
          }
          this.logError(s);
        }
      }
    } else {
      throw new Error("eq: must pass at least two arguments");
    }
    if (bEQ) {
      pass++;
    } else {
      //			@log "fail++"
      fail++;
    }
    return bEQ;
  };
  me2.fail = function(msg) {
    fail++;
    if (msg) {
      this.logError(msg);
    }
    return false; // so cal call @fail as last statement of onException, onTimeout, etc.
  };
  me2.fatal = function(msg) {
    //		console.error "fatal: #{msg}"
    clearInterval(g_timer);
    bHappy = false;
    bRunning = false;
    return util.exit(msg);
  };
  //DUP
  //TODO: manufacture?
  me2.log = function(s, o, opt) {
    //		console.log "*********** s=#{s}"
    //		console.log "*********** o=#{o}"
    //		console.log "*********** opt=#{opt}"
    if (trace.UT_TEST_LOG_ENABLED) {
      return util.logBase(`${test.cname}/${test.tn}`, s, o, opt);
    }
  };
  me2.logError = function(s, o, opt) {
    //		console.log "logError: bRunToCompletion=#{@bRunToCompletion}"
    if (this.bRunToCompletion) {
      return util.logBase(`${test.cname}/${test.tn}`, `ERROR: ${s}`, o, opt);
    } else {
      util.logBase(`${test.cname}/${test.tn}`, `FATAL_ERROR: ${s}`, o, opt);
      return util.exit("logError called with @bRunToCompletion=false");
    }
  };
  me2.logCatch = function(s, o, opt) {
    if (this.bRunToCompletion) {
      return util.logBase(`${test.cname}/${test.tn}`, `CATCH: ${s}`, o, opt);
    } else {
      util.logBase(`${test.cname}/${test.tn}`, `FATAL_CATCH: ${s}`, o, opt);
      //if node
      return process.exit(1);
    }
  };
  //endif
  me2.logFatal = function(s, o, opt) {
    util.logBase(`${test.cname}/${test.tn}`, `FATAL: ${s}`, o, opt);
    return util.exit();
  };
  me2.logSilent = function(s, o, opt) {
    return util.logBase(`${test.cname}/${test.tn}`, s, o, {
      bVisible: false
    });
  };
  me2.logTransient = function(s, o, opt) {
    if (this.bRunToCompletion) {
      return util.logBase(`${test.cname}/${test.tn}`, `TRANSIENT: ${s}`, o, opt);
    } else {
      util.logBase(`${test.cname}/${test.tn}`, `FATAL_TRANSIENT: ${s}`, o, opt);
      return util.exit("logError called with @bRunToCompletion=false");
    }
  };
  me2.logWarning = function(s, o, opt) {
    return util.logBase(`${test.cname}/${test.tn}`, `WARNING: ${s}`, o, opt);
  };
  return me2.pass = function() {
    pass++;
    return true; // so can call @pass() as last statement of onException, onTimeout, etc.
  };
};

aGenerate = (cmd) => {
  return function(tn, fn) {
    var opts;
    //		console.log "$$$$$$$$$$$$$0 #{arguments[0]}"
    //		console.log "$$$$$$$$$$$$$1 #{arguments[1]}"
    //		console.log "$$$$$$$$$$$$$2 #{arguments[2]}"
    //		console.log "$$$$$$$$$$$$$3 #{arguments[3]}"
    if (Object.prototype.toString.call(fn) === '[object Object]') {
      opts = fn;
      //			O.LOG "args", arguments
      //			O.LOG "found", opts
      //			O.LOG arguments[2]
      fn = arguments[2];
    }
    if (bRunning && t_depth === 1) {
      this.logFatal(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
    }
    //		@log "found async: #{tn} --> #{@__CLASS_NAME}"
    return testList.unshift({
      bEnabled: false,
      cmd: cmd,
      cname: this.__CLASS_NAME,
      tn: tn,
      fn: fn,
      opts: opts,
      path: `${this.__CLASS_NAME}${path}/${tn}`
    });
  };
};

testGenerate = (cmd) => {
  return function(tn, fn) {
    var opts;
    if (Object.prototype.toString.call(fn) === '[object Object]') {
      opts = fn;
      fn = arguments[2];
    }
    if (bRunning) {
      if (++t_depth === 2) {
        this.logFatal(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
      }
      fn();
      return --t_depth;
    } else {
      //			console.log "found test: #{tn}: cmd=#{cmd}"
      return testList.unshift({
        bEnabled: false,
        cmd: cmd,
        cname: this.__CLASS_NAME,
        tn: tn,
        fn: fn,
        opts: opts,
        path: `${this.__CLASS_NAME}${path}/${tn}`
      });
    }
  };
};

sectionGenerate = (cmd) => {
  return function(tn, fn) {
    var opts;
    if (typeof tn !== "string") {
      throw 0;
    }
    if (typeof fn !== "function") {
      throw 0;
    }
    if (Object.prototype.toString.call(fn) === '[object Object]') {
      opts = fn;
      fn = arguments[2];
    }
    if (bRunning && t_depth === 1) {
      this.logFatal(`NESTED t: the parent of '${tn}' is also a test; change to 's' (section)`);
    }
    //		@log "found section: #{tn}"
    testStack.push(tn);
    path = '/' + testStack.join('/');
    //		console.log "sectionGenerate: #{path}"

    //		testList.unshift
    //			bEnabled: false
    //			cmd: cmd
    //			cname: @__CLASS_NAME
    //			tn: tn
    //			fn: fn
    //			opts: opts
    //			path: path
    fn.bind(this)({
      tn: tn
    });
    return testStack.pop();
  };
};

//H: overloaded between UT runner and superclass
module.exports = UT = class UT extends Base {
  constructor(bRunToCompletion, fnCallback, opts1 = {}, WORK_AROUND_UT_CLASS_NAME_OVERRIDE) {
    var ref;
    super("I DO NOT UNDERSTAND WHY I CANNOT PASS @__CLASS_NAME HERE and I don't know why it works when I don't!!!");
    this.bRunToCompletion = bRunToCompletion;
    this.fnCallback = fnCallback;
    this.opts = opts1;
    this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE = WORK_AROUND_UT_CLASS_NAME_OVERRIDE;
    //		@log "bRunToCompletion=#{@bRunToCompletion}"
    //		O.LOG @opts
    this.__CLASS_NAME = (ref = this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE) != null ? ref : this.constructor.name;
    testIndex = "pre";
    bRunning = false;
  }

  //COMMAND: asynchronous test
  _A(a, b, c) {}

  _a(a, b, c) {}

  A(a, b, c) {
    return aGenerate('A').bind(this)(a, b, c);
  }

  a(a, b, c) {
    return aGenerate('a').bind(this)(a, b, c);
  }

  //COMMAND: section / directory of tests
  _S(a, b, c) {}

  _s(a, b, c) {}

  S(a, b, c) {
    return sectionGenerate('S').bind(this)(a, b, c);
  }

  s(a, b, c) {
    return sectionGenerate('s').bind(this)(a, b, c);
  }

  //COMMAND: synchronous test
  _T(a, b, c) {}

  _t(a, b, c) {}

  T(a, b, c) {
    return testGenerate('T').bind(this)(a, b, c);
  }

  t(a, b, c) {
    return testGenerate('t').bind(this)(a, b, c);
  }

  next() {
    var bExpectException, ex, failSave, fnBoundObjectThis, handle, objectThis, passSave, pr, ref, ref1, test, utParameter;
    if (!bRunning) {
      return;
    }
    objectThis = this;
    //H: is this while loop even used anymore?
    while (testIndex < testList.length) {
      if (iterations++ > INFINITE_LOOP_DETECTION_ITERATIONS) {
        this.logFatal(`infinite loop detected (stopped at ${iterations} iterations)`);
      }
      //			@log "#{testListSaved} VS #{testList.length}"
      if (testListSaved !== testList.length) {
        this.logFatal("testList corruption");
      }
      test = testList[testIndex];
      test.opts = Object.assign({}, this.opts, (ref = this.opts) != null ? (ref1 = ref.perTestOpts) != null ? ref1[test.cname] : void 0 : void 0, test.opts);
      delete test.opts.perTestOpts;
      if (trace.UT_TEST_PRE_ONE_LINER || 1) {
        //			O.LOG "next.opts:", test.opts

        // iter=#{iterations}
        //			@log "================== ##{testIndex+1}/#{testList.length} #{test.cname} #{test.cmd}:#{test.tn}#{if trace.DETAIL then ": path=#{test.path}" else ""}"			if trace.UT_TEST_PRE_ONE_LINER
        this.log(`================== #${testIndex + 1} ${test.path}`);
      }
      if (test.bRun) {
        this.logFatal("already run!");
      } else {
        test.bRun = true;
      }
      switch (test.cmd) {
        case 'a':
        case 'A':
          handle = null;
          pr = new Promise((resolve, reject) => {
            var ex, fn2, ms, utParameter;
            //						@log "ASYNC #{test.cname} #{test.tn} PATH=#{test.path}"	# type=#{typeof test.fn} fn=#{test.fn}"
            fn2 = decorate(test, test.fn, objectThis);
            utParameter = {
              resolve: resolve,
              reject: reject
            };
            decorateJustObject(test, utParameter);
            //						O.LOG utParameter
            ms = utParameter.opts.timeout;
            //						@log "setting timer: #{ms}ms"
            handle = setTimeout(() => {
              var bExpectTimeout, fnBoundObjectThis;
              bExpectTimeout = false;
              if (test.opts.onTimeout != null) {
                utParameter = {};
                decorateJustObject(test, utParameter);
                fnBoundObjectThis = decorate(test, test.opts.onTimeout, objectThis);
                bExpectTimeout = fnBoundObjectThis(utParameter);
              }
              //									@log "a: bExpectTimeout=#{bExpectTimeout}"
              if (bExpectTimeout || test.opts.expect === "TIMEOUT") {
                resolve();
                return;
              }
              this.log(`TIMEOUT (${ms}ms) in "${test.cname}/${test.tn}"`);
              fail++;
              return reject("TIMEOUT");
            }, ms);
            try {
              return fn2(utParameter);
            } catch (error) {
              ex = error;
              clearTimeout(handle);
              this.logCatch(`a/A exception in '${test.cname}/${test.tn}' DOES THIS EVER HAPPEN?`, ex);
              if (!this.bRunToCompletion) {
                return process.exit(1);
              }
            }
          }).then(() => {
            clearTimeout(handle);
            pass++;
            return this.post("a-then");
          }).catch((ex) => {
            clearTimeout(handle);
            //						if ex is "TIMEOUT" and test.opts.expect is "TIMEOUT"
            //							pass++
            //							@post "a-expect-TIMEOUT"
            if (ex !== "TIMEOUT") {
              fail++;
              this.logCatch("a-cmd", ex);
            }
            if (!this.bRunToCompletion) {
              process.exit(1);
            }
            return this.post("a-catch"); //IMPORTANT
          });
          return;
        case 't':
        case 'T':
          // @log "RUNNING #{test.tn} PATH=#{test.path} pass=#{pass} fail=#{fail}"#" #{test.fn}"
          passSave = pass; //TODO: do for asynch, too
          failSave = fail;
          try {
            //TODO: pass in node arguments, too
            if (++t_depth === 2) {
              this.logFatal(`[${test.path}] nested tests`);
            }
            utParameter = {};
            decorateJustObject(test, utParameter);
            if (typeof this.fnCallback === "function") {
              this.fnCallback("pre", "t", utParameter, objectThis);
            }
            //						O.LOG "objectThis", objectThis
            fnBoundObjectThis = decorate(test, test.fn, objectThis);
            fnBoundObjectThis(utParameter); //RV_IGNORE
            
            //						@log "back from test"
            if (fail > failSave && test.opts.expect === "EXCEPTION") {
              //							@log "restore: eliminate: pass=#{pass} fail=#{fail}"
              pass = passSave;
              fail = failSave;
            }
            if (typeof this.fnCallback === "function") {
              this.fnCallback("post", "t", utParameter, objectThis);
            }
            //						@log "say something meaningful here"										if trace.UT_TEST_POST_ONE_LINER	#TODO
            if (pass === passSave) {
              // implicit pass
              pass++;
            }
            --t_depth;
            this.post("t"); //WARNING: could cause very deep stack
          } catch (error) {
            ex = error;
            //						@log "t-catch ------", ex		#URGENT #TODO: move the try/catch exactly around the t-function call!
            --t_depth;
            bExpectException = false;
            //TODO: put stuff in common routine
            if (test.opts.onException != null) {
              utParameter = {};
              decorateJustObject(test, utParameter);
              fnBoundObjectThis = decorate(test, test.opts.onException, objectThis);
              bExpectException = fnBoundObjectThis(utParameter);
            }
            //							@log "t: bExpectException=#{bExpectException}"
            if (bExpectException || test.opts.expect === "EXCEPTION") {
              //							@log "restore: eliminate: pass=#{pass} fail=#{fail}"
              pass = passSave;
              fail = failSave; // restore fail's from eq failures
              if (pass === passSave) {
                // implicit pass
                pass++;
              }
              this.post("t-catch");
            } else {
              fail++;
              this.logCatch(`[${test.path}] t-handler`, ex);
              this.post("t-catch");
            }
          }
          return;
        case 's':
        case 'S':
          //					@log "here1"
          this.post("s");
          return;
        default:
          //					@log "here2"
          this.logFatal(`unknown cmd=${test.cmd}`);
      }
    }
  }

  //			@log "bottom of while"
  //		@log "UT-DONE ##{testIndex}/#{testList.length}"
  post(who) {
    if (++testIndex === testList.length) {
      //			@log "UT-DONE: who=#{who}"
      return bRunning = false;
    } else {
      //			@log "post: next: who=#{who}"
      return this.next();
    }
  }

  //			if g_timer
  //				@next()
  //			else
  //				console.error "g_timer is null"
  run(testHub1) { //H: UT should know NOTHING about "TestHub"
    this.testHub = testHub1;
    return new Promise((resolve, reject) => {
      var bFoundOverride, test;
      if (bRunning) {
        throw 0;
      }
      if (bRan) {
        throw 0;
      }
      bRan = true;
      msStart = Date.now();
      //			@log "run: test count=#{testList.length} CLOUD=#{@testHub.c.CLOUD}"
      if (testList.length > 0) {
        testList.reverse();
        testIndex = 0;
        while (testIndex < testList.length) {
          test = testList[testIndex];
          //				@log "pre: ##{testIndex} #{test.cmd}:#{test.tn}: #{test.path}"
          testIndex++;
        }
        testIndex = 0;
        bRunning = true;
        iterations = 0;
        bFoundOverride = false;
        testList.forEach((test) => {
          if (/^[A-Z]/.test(test.cmd)) {
            //						@log "found ut override: #{test.tn}"
            test.bEnabled = true;
            return bFoundOverride = true;
          }
        });
        testListSaved = testList.length;
        if (bFoundOverride) {
          testList = testList.filter((test) => {
            return test.bEnabled;
          });
          //					console.log "FIRST"
          //					@log "test", a:"a", false
          //					@log "test", a:"a", true
          //					@log "ONE", "TWO", "THREE"
          //					util.abort "NOW"

          //					fn = (a, b) ->
          //						O.LOG arguments
          //					fn "a", "b"
          this.log(`Found ${testListSaved} test${(testListSaved === 1 ? "" : "s")}, but also ${testList.length} override${(testList.length === 1 ? "" : "s")}`);
        }
        if (testList.length > 0) {
          testListSaved = testList.length;
          this.next();
          //HACK: utilize this timer to keep node running until all tests have completed
          return g_timer = setInterval(() => {
            var secs;
            if (!bRunning) {
              if (bHappy) {
                secs = Math.ceil((Date.now() - msStart) / 1000);
                this.log("======================================================");
                this.log(`all unit tests completed: [${secs} second${(secs === 1 ? "" : "s")}] total=${pass + fail}: ${(!fail ? "PASS" : "pass")}=${pass} ${(fail ? "FAIL" : "fail")}=${fail}`);
                clearInterval(g_timer);
                if (fail) {
                  return resolve(`[${secs}s] fail=${fail}`);
                } else {
                  return resolve(`[${secs}s] pass=${pass}`);
                }
              }
            }
          }, 100);
        }
      }
    });
  }

  stackReset() {
    testStack.length = 0;
    return path = '';
  }

  //if ut
  static ut(testHub) {
    //		@log "CLOUD=#{testHub.c.CLOUD}"
    return new UTUT().run(testHub);
  }

};

//endif
UTUT = class UTUT extends UT {
  run() {
    this.t("UT events", function(ut) {
      this.eq(ut.say_hi_to_peter, "Hi Pete!");
      //			.then (client) =>
      //				@log "one: #{client.one}"
      return this.testHub.startClient("/tmp/ut/UTUT").catch((ex) => {
        return this.logCatch("startClient", ex); //H: logCatch WHAT should be the parameter?
      });
    });
    this.t("opts", function(ut) {
      //			O.LOG "ut.opts=", ut.opts
      this.eq(ut.opts.aaa, "AAA");
      //			O.LOG "@opts=", @opts
      return this.eq(this.opts.aaa, "AAA");
    });
    this.t("empty log", function() {
      this.log("pre");
      this.log();
      this.log();
      this.log();
      return this.log("post");
    });
    this.s("bag", function() {
      this.t("set", function() {
        this.bag();
        this.bag.color = "red";
        return this.bag();
      });
      this.t("get", function() {
        this.bag();
        this.eq(this.bag.color, "red");
        this.bag.clear();
        this.eq(this.bag.color, void 0);
        return this.bag();
      });
      return this.t("clear invalid", function() {
        var ex;
        try {
          this.bag.clear = "this should fail";
          return this.fail("it's illegal to assign 'clear' to bag");
        } catch (error) {
          ex = error;
          return this.pass();
        }
      });
    });
    this.s("sync nesting test", function() {
      //			@log "SYNC"
      //			t = 0
      //			@log "div 0"
      //			t = t / t
      //			O.LOG this
      //			@log "hello"
      return this.s("a", (ut) => {
        //				@log "section log"
        //				@logError "section logError"
        //				@logCatch "section logCatch"
        this.s("b1", function(ut) {
          this.t("b1c1", function(ut) {});
          //						@log "test log"
          //						@logError "test logError"
          //						@logCatch "test logCatch"
          return this.t("b1c2", function(ut) {});
        });
        return this.s("b2", function(ut) {
          return this.s("b2c1", function(ut) {
            return this.t("b2c1d1", function(ut) {});
          });
        });
      });
    });
    this.s("async nesting test", function(ut) {
      return this.s("a", function(ut) {
        this.s("b1", function(ut) {
          this.a("b1c1", function(ut) {
            return setTimeout((() => {
              return ut.resolve();
            }), 3000);
          });
          //						@log "setTimeout"
          //						@log "asynch log"
          //						@logError "asynch logError"
          //						@logCatch "asynch logCatch"
          return this.a("b1c2", function(ut) {
            return ut.resolve();
          });
        });
        return this.s("b2", function(ut) {
          return this.s("b2c1", function(ut) {
            return this.a("b2c1d1", function(ut) {
              return ut.resolve();
            });
          });
        });
      });
    });
    this.t("opts parameter", {
      timeout: 1000,
      a: "a"
    }, function(ut) {
      //			@log "opts parameter"
      //			O.LOG ut.opts
      return this.eq(ut.opts.timeout, 1000);
    });
    this.a("promise timeout", {
      timeout: 100,
      expect: "TIMEOUT"
    }, function(ut) {});
    //			DO NOT CALL ut.resolve()
    this.a("onTimeout", {
      timeout: 100,
      onTimeout: function(ut) {
        this.log(`onTimeout called: ${ut.opts.timeout}=${this.opts.timeout}`);
        return true;
      }
    }, function(ut) {
      return this.log("do not call ut.resolve to force timeout");
    });
    this.s("eq", function() {
      this.t("single parameter", {
        onException: function(ut, ex) {
          //					@log "in onException"
          return this.pass();
        }
      }, function() {
        return this.eq("I feel alone");
      });
      return this.t("differing types", {
        expect: "EXCEPTION"
      }, function() {
        //				@log "in test: *** bRunToCompletion=#{@bRunToCompletion}"
        return this.eq("peter", new String("peter"));
      });
    });
    this._t("fatal", {
      comment: "can't test because it exits node",
      bManual: true,
      peter: "alvin"
    }, function() {
      //TODO: skip if bManual is true
      this.fatal();
      return this.fatal("display me on console");
    });
    return this.t("assert", {
      expect: "EXCEPTION"
    }, function() {
      this.log("hello");
      this.assert(true, "Saturday");
      return this.assert(false, "Sunday");
    });
  }

};

//endif
