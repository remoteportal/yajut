// coffeeScript.coffee: Generated by CoffeeScript 2.3.1 (coffeescript.coffee IMMED5 affects ./coffee -v)
  // process: ENV={"daemon":true,"dev":true,"instrumentation":true,"mac":true,"node":true,"node8":true,"ut":true,"source":"/Users/pete/gitlab/rn/API/Flexbase/ut.coffee"}
  //if node
var A, AP, ASS, AsyncTest, BB, Base, C, Context, DATE, EXPORTED, GG, HM, IF, IS, LL, N, O, REMOVE_ME_MS, S, SP, Section, SyncTest, TYPE, Test, Type, UT, UTBase, UTRunner, UT_UT, V, abort, bag, bagHandler, drill, duck, g_testList, json, kt, kvt, log, modMap, proxyBag, syncTestsCount, target, textFormat, trace, type, vt,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },
  indexOf = [].indexOf;

REMOVE_ME_MS = 10; //H

//else
//endif
/*
YAJUT - Yet Another Javascript Unit T e s t							a.shift "pop() by doing shift LEFT"

bottom line: unit tests must be as powerful and succinct as possible... as little boilerplate as possible... and easily controllable... to isolate correct one giving you brief
    must be fast (parallel execution), vary trace easily.  quickly stop on errors
easily extendable with native commands
rich set of primatives (dump object)
logging for posterity

=> you spend most of your time writing unit tests... make it as easy and enjoyable as possible

great support for negative testing... ... ability to "unwind" errors and remove specific expected ones

USAGE:
yajut						run current configuration
yajut conffile				run configuration stored as JSON in text file
yajut list					list all tests in directory
yajut purgelogs				forceably purge all previous log directories and files without user confirmation
yajut resetstats			forceably reset all test statistics without user confirmation
yajut -k keyword			run all tests matching keyword
yajut -r					re-run all failed tests from the exact preceeding run
yajut -s conffile			save current code-specified configuration into confifile for manual editing or re-use later

EXTENDS: Base

Server: [S]
Client: [C]

TERMINOLOGY: #H
    command			-lcmd		"called inside test": @eq (string equality), @log (log), @m (milestone)
    primative		-lprim		"structure of tests": @s (section), @t (sync test), @a (asynchronous test), @p (promise-returning test)

DESCRIPTION:
The goal of JAJUT is to be absolutely the least-friction most-terse easiest to use JS unit test system.

Taxonomy: Ability to organize tests by hierarchically:
    @s "boating", ->
    	@s "motor", ->
    	@s "sail", ->
    		@_t "high wind conditions"
    		@_t "low wind conditions"				<-- use _t so test success counts aren't artifically raised when doing top-down specificatin
    @s "farming", ->
    		@s "equipment", ->
    			@_t "tractor", ->

use skinny arrows (not fat arrows) for nested tests:
	@s "async nesting test", ->
		@s "a", ->
			@s "b1", ->
    			@t "some sync test", ->
				@a "some async test", (ut) -> ut.resolve()

The UT, for the server, choses either a blank Flexbase database or a database with small user pool
For local, it chooses either a brand-new install, or a already established user account.
server: "blank" or "std"
client: "blank" or "std"

Everything is logged.... in fact you can do @snap to take a picture of both databases and all object state at that moment in separate data directory
Promise-based, hierarchical test, minimalist and least-boilerplate, inline with source code unit test framework.

- (ut) -> vs @utMethod: the value of 'ut' parameter is that:
    - @ form is shorter
    - but using ut: a test can use closure not fat arrows (=>) to access ut properties and methods
    - but using ut: if inside a overridden child method of a sub-class: onReceive where 'this' context is the object not the ut

P-tests:
	@P "test name", (ut) ->
		Promise.resolve()
		.then =>
			@log "this chain does return promise"		BUT GENERATES  (UT004) in RN because RN promises are objects not typeof => Promise
	PROBLEMS with @p TEST DISCUSSION:
    	The problem is that TWO promises are resolved:
    		A) the test itself
    		B) @env.succ()
		NOTE: the test may not appear to return a promise object, but because it has a promise chain, a promise object *is* returned (FFF2) and the value may be a real value or null
		@p "scenario 1 BROKEN", ->
			pr = @ce().run()
			.then (po) =>
				@env.succ "Kubusschnitt"			=> FFF6: ut ITSELF resolved promise: [[Kubusschnitt]]					**NO** await	t2) too late, ERROR
				"hello"								=> FFF2: @p ut return value: promise, that is NOW resolved: [[hello]]					t1) timely
		@p "scenario 2 BROKEN", ->
			pr = @ce().run()
			.then (po) =>
				await @env.succ "Kubusschnitt"		=> FFF6: ut ITSELF resolved promise: [[Kubusschnitt]]					**YES** await	t1) timely
				"hello"								=> FFF2: @p ut return value: promise, that is NOW resolved: [[hello]]					t2) too late, suite already moved on, causes Error: done: who=undefined: mState: expected=RUNNING(2) got=DONE(3)
    	#TAKE-AWAY: I don't think @env.succ can be used with @p-tests?
    		By design, @env.succ() fires promise that was created by @ce()
		@p "scenario 3 CORRECT-FORM", ->
			pr = @ce().run()
			.then (po) =>
				@env.d()		#WORKS: don't put await

EVENTS: @events
left-open
runner-done
runner-start
test-done
test-start

@ASSERTION LIBRARY	@ASSERTLIB	@ALIB:		#EASY: ut -al (show assertion library) or -la (list assertions) or -lcmd (list commands)  #H:what are these ut.method and @method's called?
    eq			a, b, msg, o				as string equal (EQ-NOT-STRICT)				pass: (new String "6") eq 6
    Eq			a, b, msg, o				value not type (EQ-MID-STRICT)				pass: (new String "6") Eq "6"
    EQ			a, b, msg, o				value and type (EQ-STRICT)					pass: (new String "6") EQ (new String "6")
    EQO			a, b, msg, o				same object (EQ-SAME)						pass: o EQO o
    eqfile		a, b, msg, o				file contents (EQ-FILE)						pass: read(file) compare read(file)

FEATURES:
- ability to add or remove flags run-over-run: +flag  /flag or something
- almost everything is customizable: mTypes, logging, primatives (t, a, p, s, etc.)

NON-FEATURES:
- human "sentence" readable assertion library: dot.dot.dot crap.   For me, brevity is way more important

ERRORS:		
UT001 Unknown test option: $
UT002 Unknown mType=$
UT003 You are not allowed to define the method named '$' because it clashes with a built-in property
UT004 Promise expected but not returned from P-test
UT005 P-tests aren't supported by ReactNative
UT006 opts must be object
UT007 opts.tags must be CSV
UT008 asynch opt not allowed with $
UT009 Invalid test tag: $
UT010 two children can't have exactly the same name: $			FUTURE

GENERALIZE:
- mType's

TODOs
- log EVERY run to new timestamp directory with tests ran in the directory name... store ALL data
	- two files: currently enabled trace and ALL TRACE
	- auto-zip at end
	- directory: 2018-05-01 6m tot=89 P_88 F_1 3-ModuleName,DeathStar TR=UT_TEST_POST_ONE_LINER,ID_TRANSLATE.zip
		traceSelected.txt
		traceAll.txt
		src/...
- if run all TESTS report how many are disabled _
- put cleanup in opts  but that means @client and @server or implement our own timeout mechanism, again, inside here:
- onPost -> @testHub.directoryRemoveRecursiveForce()
- actually:  @testHub.directoryGetTempInstanceSpace
- test auto-discovery so don't need to explicity list in tests.coffee
- add @rnd() functions
- validate system-level options parameter names
- validate per-unit test on-the-fly options for mispellings
- @defined x
- at beginning of test, silently dump all it's options
- EXCEPTION to check the actual type of exception... many false positives/negatives unless do THAT
- @db_log (snapshot)
- @db_diff	do snapshot into delta arrays
- only create tables once per section, and is run een if only a single test override in place... not sure how to pull this off.  @s -> if @testing ...
- auto-teardown: you register setup things and what to do with them... if anything goes wrong they are torn down
- write test results in JSON file so that can do "query" like "when was the last time this test passed?"
- children ndoes that "build" to the current overridden child node... preceeding steps...really great idea!
- designate test as a negative test... @tn... @n...  @an...?
- run all asynch tests at same time concurrently
- classify tests: positive, negative, boundary, stress, unspecified, etc.
- run all tests < or > than so many milliseconds
- capitalize section ("S") overrides to run entire sections
- purposeful 1000ms delay between tests to let things settle
- count the number of disabled tests
- include string diff report functions to make it really easy to ascertain why @eq fails
#EASY: dump all possible test options... in grid with S T A section/test/asynch columns in front, option, desc, and example
#DREAM: new option def:
    @t "some test",
			def:
				em: "Deanna is beautiful"
				b: "b-value"
			exceptionMessage: @em			HOW DO THIS?
		, ->
			throw @em
    should be readable by ut.a, @a, and other parameters.  Ensure don't stomp on system
- have eventFire be a wrapper that calls the real cb and if not return true the call process?.exit?
- keep the same numbers, even if overrides
- manufacture variables than can be passed into routines that track what values they are set to to see if they exceed, etc.  using proxy
- run this test: UT.Peter.capitalize (local)     PASS=2 instead of 1
- pass all stdout and stderr from the test
- pass metrics like # of database hits, etc.
- test info siloed--none commingled trace and logging.  even though five concurrent tests running, all the trace is separate.  Even threads of particular test are siloed.
- perhaps put the "assertion library" tightly in it's own silo'ed area?
- @ut in different text color
- @ut "I'm green", color:green
- test setup and teardown in different text color
- ut -hi		implement a shell-type history... shows last 30 unique commands with a number... type number: 14<return>
- on test failure, read each and every file in the test.directory and add to the log for post-mortem analysis
- client/server with different trace colors
- track which tests seem to fail occasionally ("which dones are transient failures"); track by name and desc (NOT number)
- ut -sum			if error I don't think it tells you which test it died on
- ___7  25:06 [SyncTest] ==================== #6 t BaseUT logging/logError
  ___8  25:06 [AsyncTest] ==================== #7 a BaseUT logging/soon			<---- line up

ROUNDUP:
- https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2018-f68950900bc3

KNOWN BUGS:
-
 */
//GITHUB: 
//NOTE: ILLEGAL TO USE context instance in this file only static class methods (why? instance is domain specific)
// *** #IMPORT2
//IMPORT2 Context
Base = require('./Base');

Context = require('./Context');

trace = require('./trace');

//ORIGIN: ~/github/coffeescript/peter.coffee: tr array
abort = Context.abort;

BB = Context.BB;

GG = Context.GG;

HM = Context.HM;

kt = Context.kt;

kvt = Context.kvt;

vt = Context.vt;

TYPE = Context.TYPE;

Type = Context.Type;

type = Context.type;

modMap = Context.modMap;

A = modMap.A;

AP = modMap.AP;

ASS = modMap.ASS;

C = modMap.C;

DATE = modMap.DATE;

IS = modMap.IS;

LL = modMap.LL;

N = modMap.N;

O = modMap.O;

S = modMap.S;

SP = modMap.SP;

textFormat = modMap.textFormat;

V = modMap.V;

duck = V.duck;

drill = O.drill;

json = V.json;

IF = AP.IF;

g_testList = []; //RABBIT-HOLE: spent 1h trying to move into UTBase but got reset every time... ended up reverting back to commit 2018-11-18


//REVISIT
log = function() {
  return global.log.apply(this, arguments); //PATTERN	#R
};

bag = Object.create({
  clear: function() {
    var k;
    for (k in bag) {
      if (k !== "clear") {
        delete bag[k];
      }
    }
  }
});

//PATTERN: target is function
target = function(cmdUNUSED_TODO) {
  var _, k, sans, v;
  if (trace.UT_BAG_DUMP) {
    //	log "HI: cmd=#{cmdUNUSED_TODO}"
    sans = Object.assign({}, bag);
    delete sans.clear;
    O.LOG(sans); //NOT-DEBUG
    if (_ = O.CNT_OWN(sans)) {
      log(`bag: ${_} propert${(_ === 1 ? "y" : "ies")}:`);
      for (k in sans) {
        v = sans[k];
        if (typeof v === "object") {
          log(`bag: ${k} =`);
          O.LOG(v);
        } else {
          log(`bag: ${k} = ${V.DUMP(v)}`);
        }
      }
    } else {
      log("bag: empty");
    }
  }
};

//PATTERN: target isn't actually proxy target (ONLY WORKS FOR SINGLETONS)
bagHandler = { // "traps"
  get: function(target, pn) {
    //		log "read from bag: #{pn} => #{bag[pn]}"
    return bag[pn];
  },
  set: function(target, pn, pv) {
    if (trace.UT_BAG_SET) { //R
      //H: 	I don't know why this following line isn't green with -hl CLI
      global.log(`UT bagHandler: set: ${pn}=${pv} <${typeof pv}>`);
    }
    if (pn === "clear") {
      throw Error("clear is not appropriate");
    }
    return bag[pn] = pv;
  }
};

proxyBag = new Proxy(target, bagHandler);

UTBase = class UTBase extends Base { //@UTBase
  constructor() {
    super();
    this.const("NEG", 0);
    this.const("PROOF", 1);
    //													  FAILURE HANDLER
    this.const("FAIL_ASSERT", 1); // onAssertFail()
    this.const("FAIL_EQ", 2); // onEqFail()
    this.const("FAIL_ERROR", 3); // onError() FUTURE
    this.const("FAIL_EXCEPTION", 4); // onException()
    this.const("FAIL_MARKERS", 5); // onMarkers()
    this.const("FAIL_TIMEOUT", 6); // onTimeout()
    this.const("FAIL_UNFAIL", 7); // onUnfail()		something was supposed to fail but didn't!
    this.const("FAIL_UNEXPECTED_PROMISE", 8); // onUnexpectedPromise
    this.const("failTypes", [null, "Assert", "Eq", "Error", "Exception", "Markers", "Timeout", "Unfail", "Unexpected_Promise"]);
    O.___(this, "failSnip", function(mFail = this.mFail) {
      return `${this.failTypes[mFail]}(${mFail})`;
    });
    this.const("FM_FAILFAST", 0);
    this.const("FM_FAILTEST", 1);
    this.const("FM_RUNALL", 2);
    this.const("STAGE_SETUP", 1);
    this.const("STAGE_RUN", 2);
    this.const("STAGE_TEARDOWN", 3);
    this.const("STATE_WAITING", 1);
    this.const("STATE_RUNNING", 2);
    this.const("STATE_DONE", 3);
    this.const("STATE_LIST", [null, "WAITING", "RUNNING", "DONE"]);
    this.const("stateFrag", function(m = this.mState) {
      return `${this.STATE_LIST[m]}(${m})`;
    });
    this.const("WHY_ALL_TESTS_RUN", 1);
    this.const("WHY_FAIL_FAST", 2);
    this.const("WHY_FATAL", 3);
    this.const("WHY_TOLD_TO_STOP", 4);
    this.const("WHY_CLI", 5);
    this.const("WHY_NO_TESTS_FOUND", 6);
    this.const("WHY_LIST", [null, "ALL_TESTS_RUN", "FAIL_FAST", "FATAL", "TOLD_TO_STOP", "CLI", "WHY_NO_TESTS_FOUND"]);
    O.MAKE_LG(this, "UT_RUNNER", trace, "UT_RUNNER", () => {
      var ref;
      return (ref = this.__CLASS_NAME2) != null ? ref : this.__CLASS_NAME;
    });
  }

};


//#H: overloaded between UT runner and superclass
EXPORTED = UT = class UT extends UTBase { //@UT
  constructor(WORK_AROUND_UT_CLASS_NAME_OVERRIDE) {
    var ref;
    super();
    //COMBINE: MAKE*
    this.MAKEa = this.MAKEa.bind(this);
    this.MAKEt = this.MAKEt.bind(this);
    this.MAKEs = this.MAKEs.bind(this);
    this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE = WORK_AROUND_UT_CLASS_NAME_OVERRIDE;
    this.__CLASS_NAME = (ref = this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE) != null ? ref : this.constructor.name;
    this._path = '';
    this.testStack = [];
  }

  MAKEa(cmd) {
    boundMethodCheck(this, UT);
    return function(tn, fn) {
      var opts;
      if (IS.o(fn)) {
        opts = fn;
        fn = arguments[2];
      }
      if (typeof fn !== "function") {
        abort(`MAKEa: [${tn}] MISSING fn`);
      }
      if (tn.includes('/')) {
        throw Error(`MAKEa: path=[${this._path}]: slash (/) not allowed in tn=${tn}`);
      }
      //		if bRunning and t_depth is 1 => @lgFatal "NESTED t: the parent of '#{tn}' is also a test; change to 's' (section)"
      //		@lg "found async: #{tn} --> #{@__CLASS_NAME}"
      //		@lg "CLASS=#{@__CLASS_NAME}  TN=#{tn} PATH=#{path}"
      //		@lg "#{@__CLASS_NAME}#{path}/#{tn}"

      //			@log "path=#{@_path}"
      return new AsyncTest({
        cmd: cmd,
        cname: this.__CLASS_NAME,
        common: Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(function(mn) {
          return mn !== "constructor" && mn !== "run";
        }),
        fn: fn,
        hier: `${this._path}/${tn}`,
        tn: tn,
        opts: opts,
        parent: this,
        path: `${this.__CLASS_NAME} ${this._path}/${tn}`
      });
    };
  }

  MAKEt(cmd) {
    boundMethodCheck(this, UT);
    return function(tn, fn) {
      var opts;
      if (IS.o(fn)) {
        opts = fn;
        fn = arguments[2];
      }
      if (typeof fn !== "function") {
        abort(`MAKEa: [${tn}] MISSING fn`);
      }
      if (tn.includes('/')) {
        throw Error(`MAKEa: path=[${this._path}]: slash (/) not allowed in tn=${tn}`);
      }
      return new SyncTest({
        cmd: cmd,
        cname: this.__CLASS_NAME,
        fn: fn,
        hier: `${this._path}/${tn}`,
        tn: tn,
        opts: opts,
        parent: this,
        path: `${this.__CLASS_NAME} ${this._path}/${tn}`
      });
    };
  }

  MAKEs(cmd) {
    boundMethodCheck(this, UT);
    return function(tn, fn) { //ALT-ARGS: tn, opts, fn
      var opts;
      if (IS.o(fn)) {
        opts = fn;
        fn = arguments[2];
        O.validate(opts, {
          onlyCSV: "ME_MAKEs"
        });
      }
      if (!IS.s(tn)) {
        throw "MAKEs: 1st arg must be s";
      }
      if (!IS.fn(fn)) {
        throw "MAKEs: fn missing";
      }
      if (tn.includes('/')) {
        throw Error(`MAKEa: path=[${this._path}]: slash (/) not allowed in tn=${tn}`);
      }
      this.testStack.push(tn);
      this._path = this.testStack.join('/');
      fn.bind(this)({
        opts: opts,
        parent: this,
        tn: tn
      });
      this.testStack.pop();
      return this._path = this.testStack.join('/');
    };
  }

  //		log "END: MAKEs: #{@_path}"

  //COMMAND: asynchronous test
  _A(a, b, c) {}

  _a(a, b, c) {}

  A(a, b, c) {
    return this.MAKEa('A').bind(this)(a, b, c); //REVISIT: apply...
  }

  a(a, b, c) {
    return this.MAKEa('a').bind(this)(a, b, c);
  }

  //COMMAND: asynchronous test
  _P(a, b, c) {}

  _p(a, b, c) {}

  // if rn
  //	P: (a, b, c) -> throw Error "UT005 P-tests aren't supported by ReactNative"
  //	p: (a, b, c) -> throw Error "UT005 P-tests aren't supported by ReactNative"
  // else
  P(a, b, c) {
    return this.MAKEa('P').bind(this)(a, b, c);
  }

  p(a, b, c) {
    return this.MAKEa('p').bind(this)(a, b, c);
  }

  // endif

  //COMMAND: section / to build a hierarchy of tests
  _S(a, b, c) {}

  _s(a, b, c) {}

  S(a, b, c) {
    return this.MAKEs('S').bind(this)(a, b, c);
  }

  s(a, b, c) {
    return this.MAKEs('s').bind(this)(a, b, c);
  }

  //COMMAND: synchronous test
  _T(a, b, c) {}

  _t(a, b, c) {}

  T(a, b, c) {
    return this.MAKEt('T').bind(this)(a, b, c);
  }

  t(a, b, c) {
    return this.MAKEt('t').bind(this)(a, b, c);
  }

  static s_runner() {
    return UTRunner; //WORKAROUND: so don't have to change all the individual tests
  }

  static UTRunner() {
    return UTRunner; //PATTERN: not sure why can't just pass UTRunner itself (instead of function returning value)
  }

  static s_ut() {
    return new UT_UT().run();
  }

};

//END:UT
Test = class Test extends UTBase { //@Test #@test
  constructor(optsOrig, optsMore) {
    var _, failList_CLOSURE, j, k, len, ref, ref1, ref2, ref3, v, validOptsMap, validTagsMap;
    super();
//		@lg "Test constructor: optsOrig", optsOrig
    for (k in optsOrig) {
      v = optsOrig[k];
      this[k] = v;
    }
    for (k in optsMore) {
      v = optsMore[k];
      this[k] = v;
    }
    _ = `${this.cmd} ${this.path // _ = "CN=#{@__CLASS_NAME} PATH=[#{@path}]"
}`;
    this.bForcePass = false;
    this.markers = "";
    this.pass = 0;
    failList_CLOSURE = this.failList = [];
    //GENERALIZE #PRODUCTIONIZE
    validOptsMap = null;
    validTagsMap = {
      daemon: "daemon must be running",
      human: "meant only to be run manually by a human (not in a suite of tests)",
      internet: "only run test if connected to the Internet if '-tagy internet' option specified",
      localdaemon: "HELP: local daemon must be running at: ws://localhost:4000"
    };
    if (this.opts) {
      if (!IS.o(this.opts)) {
        console.log(`UT006 pre-flight failure: opts must be object: ${this.path //H: not console.log
}`);
        O.LOG(this.opts);
        return void 0;
      }
    }
    if ((ref = this.opts) != null ? ref.tags : void 0) {
      if (!IS.csv(this.opts.tags)) {
        console.log(`UT007 pre-flight failure: opts.tags must be CSV: ${this.path //H: not console.log
}`);
        O.LOG(this.opts.tags);
        return void 0;
      }
    }
    this.opts = (ref1 = this.opts) != null ? ref1 : {};
    this.opts.tags = (ref2 = this.opts.tags) != null ? ref2 : "";
    this.tags = {};
    if (this.opts.tags.length) {
      ref3 = this.opts.tags.split(',');
      for (j = 0, len = ref3.length; j < len; j++) {
        k = ref3[j];
        if (k in validTagsMap) {
          this.tags[k] = true;
        } else {
          console.log(S.autoTable(validTagsMap, {
            headerMap: {
              key: "tag",
              value: "description"
            }
          }));
          console.log();
          console.log("UT009 Invalid test tag:"); //H: not console.log
          console.log(S.autoTable({
            "file:": this.cname,
            "path:": this.hier,
            "tag:": k
          }));
          return void 0;
        }
      }
    }
    //				console.log "> tag: #{k}"
    this.optsCSV = Object.getOwnPropertyNames(this.opts).filter((tag) => {
      return tag !== "tags";
    }).sort().join(',');
    this.tagsCSV = this.opts.tags;
    if (this.opts.mkr) {
      this.mkr = this.opts.mkr;
      delete this.opts.mkr;
    }
    //			console.log "FOUND mkr: #{@mkr}"
    delete this.opts.tags; // remove from options since it's been promoted to top-level
    this.Fail = class Fail extends UTBase { //@Fail	#@fail   #PATTERN
      constructor(mFail1, summary1, detail1, o1, opts1) { //RENAME: @o -> @v
        super();
        this.mFail = mFail1;
        this.summary = summary1;
        this.detail = detail1;
        this.o = o1;
        this.opts = opts1;
        failList_CLOSURE.unshift(this);
        this.lg(`fail constructor: ${this.failSnip(this.mFail)} ${this.summary} nowLen=${failList_CLOSURE.length}`, this.o);
        this.bEnabled = true;
        //				console.log "Fail=#{V.Type @o}"
        if (V.Type(this.o) === "Error") {
          //					console.log "got error <<<<<<<<<<<<<<<"
          this.ex = this.o;
          this.o = null;
          this.stack = this.ex;
        }
      }

      //					@lg "111*^20 stack.length=#{@stack?.length}"
      //					@lg "222*^20 stack.length=#{@stack?.length}", @ex
      //				else
      //					console.log "NOT ERROR"
      //					O.DUMP @o

      //					https://www.stacktracejs.com
      //					console.log "console.trace():"
      //					console.trace()
      //					err = new Error @msg
      //					@stack = err.stack
      //				@lg "stack", stack
      //				O.LOG @

      //				@lg "*^20 mFail=#{@failSnip @mFail}"				#POP
      //				@lg "*^20 summary=#{@summary}"
      //				@lg "*^20 detail=#{@detail}"
      //				@lg "*^20 o=#{@o}"
      //				@lg "*^20 stack.length=#{@stack?.length}"

      //			full: -> Context.textFormat.red "#{@one()}\n\n#{@detail}#{SP.d @stack, "\n#{@stack}"}"
      full() {
        return `${this.one()}\n\ndetail=${this.detail}\no=${O.DUMP(this.o, this.opts)}\n${SP.d(this.stack, `\n${this.stack}`)}`;
      }

      heal() {
        return this.bEnabled = false;
      }

      one() {
        return `Fail: ${this.failSnip(this.mFail)}${SP.d(this.msg, this.msg)}: ${this.summary //URGENT: put in subroutine
}`;
      }

    };
    this.one = function() {
      return `#${this.testIndex} ${_}`;
    };
    this.one2 = function() {
      return `Test: ${this.one()}: cmd=${this.cmd} enabled=${this.bEnabled} mState=${this.stateFrag()} mStage=${this.mStage}${SP.d(this.opts.mutex, `mutex=${this.opts.mutex}`)} pf=${this.pass}/${this.failList.length}`;
    };
    this.one3 = function() {
      return `${this.one2()} [${this.optsCSV}]`;
    };
    g_testList.unshift(this);
  }

  after(mFail, ex_s_null) {
    var EXPECT, PR, _, bFound, detail, expectMap, fail, i, j, k, kUC, l, len, p, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s;
    //		@assert mFail?, "mFail"		wrong: mFail is undefined or null if success
    this.lg("#".repeat(60));
    this.lg(`after${(mFail != null ? `: ${this.failSnip(mFail)}` : "")}: ${this.one2() //, ex_s_null
}`);
    
    //H #DOMAIN: remove this from UT.coffee... onAfter()      	perhaps @env.onAfter()
    if (((ref = this.env) != null ? (ref1 = ref.server) != null ? (ref2 = ref1.deliverObj) != null ? (ref3 = ref2.config) != null ? (ref4 = ref3.deliverList) != null ? ref4.length : void 0 : void 0 : void 0 : void 0 : void 0) > 1) {
      console.log(`server: not delivered: ${this.env.server.deliverObj.config.deliverList.length}`);
    }
    if ((ref5 = this.env) != null ? (ref6 = ref5.server) != null ? (ref7 = ref6.deliverObj) != null ? ref7.queuedCntGet() : void 0 : void 0 : void 0) {
      console.log("AFTER: " + this.env.server.deliverObj.oneQ());
    }
    
    //		@lg "failList.length=#{@failList.length}"
    if (mFail === this.FAIL_ERROR || mFail === this.FAIL_EXCEPTION || mFail === this.FAIL_TIMEOUT || mFail === this.FAIL_UNEXPECTED_PROMISE) { //MANAGE #ADD #OTF
      //			@lg "on-the-fly append mFail to failList"
      this.FAIL(mFail, null, null, ex_s_null);
    }
    //		@lg "DUMP IT ALL", @failList
    if (this.opts.markers != null) {
      if (this.opts.markers !== this.markers) {
        s = `\n-----------------------\nmarkers: expected: ${this.opts.markers}\nmarkers: got     : ${this.markers}\n-----------------------`;
        this.FAIL(this.FAIL_MARKERS, null, null, s);
      }
    }
    expectMap = {};
    if (this.opts.expect) {
      ref8 = this.opts.expect.split(',');
      for (j = 0, len = ref8.length; j < len; j++) {
        k = ref8[j];
        kUC = k.toUpperCase();
        if (_ = this[`FAIL_${kUC}`]) {
          //					@lg "after: expectMap[#{kUC}]=#{_}"
          expectMap[kUC] = _;
        } else {
          throw Error(`Invalid expect type: '${k}'`);
        }
      }
    }
//		@lg "failList.length=#{@failList.length}"
    for (EXPECT in expectMap) {
      this.lg(`EXPECT=${EXPECT}`);
      bFound = false;
      ref9 = this.failList;
      for (i = l = ref9.length - 1; l >= 0; i = l += -1) {
        fail = ref9[i];
        this.lg(`--> ${fail.one()}   (compare ${this.failTypes[fail.mFail].toUpperCase()} vs ${EXPECT
        //, fail
})`);
        if (this.failTypes[fail.mFail].toUpperCase() === EXPECT) {
          this.lg("  EXPECT found... so don't call @FAIL");
          bFound = true;
        }
      }
      if (!bFound) {
        this.lg("+ add");
        this.FAIL(this.FAIL_UNFAIL, `Expected ${EXPECT} but didn't find one`, null, null);
      }
    }
    if (this.opts.exceptionMessage != null) {
      //			@lg "scanning for #{@opts.exceptionMessage}"
      bFound = false;
      ref10 = this.failList;
      for (i = p = ref10.length - 1; p >= 0; i = p += -1) {
        fail = ref10[i];
        //				@lg "--> #{fail.one()}" #, fail
        if (fail.mFail === this.FAIL_EXCEPTION) {
          //					@lg "found exception"
          if (fail.ex.message === (_ = this.opts.exceptionMessage)) {
            bFound = true;
            //						@lg "remove because exceptionMessage match"
            this.failList.splice(i, 1);
          }
        }
      }
      if (!bFound) {
        //				@lg "exceptionMessage not found"
        detail = '^' + V.COMPARE_REPORT(ex_s_null.message, _, {
          preamble: "ex.message\n\n@opts.exceptionMessage"
        });
        //				@lg "+ add"
        this.FAIL(this.FAIL_ERROR, "exceptionMessage mismatch", detail, null);
      }
    }
    //H #UNSTABLE: if TWO promises, depending on the order in which they resolve... the splice may be incorrect order and will be indeterminate (WRONG) deletion
    //WORKAROUND: only have a single bagHandler... only guaranteed to work with a single bagHandler
    //ARCHITECTURE: or guarantee serial bagHandler execution
    PR = new Promise((resolve, reject) => {
      var THAT, a, afterHandler, mn, q, ref11, ref12, ref13, rv;
      afterHandler = (fail) => {
        if (!fail.bEnabled) {
          //					@lg "onHandler: remove i=#{i}"
          return this.failList.splice(i, 1);
        }
      };
      a = [];
      ref11 = this.failList;
      //		@lg "look for onHandler"
      for (i = q = ref11.length - 1; q >= 0; i = q += -1) {
        fail = ref11[i];
        //			@lg "--> #{fail.one()}" #, fail
        if (_ = this.opts[mn = `on${this.failTypes[fail.mFail]}`]) {
          this.fail = fail;
          THAT = Object.assign({}, this, this.runner.OPTS, (ref12 = this.runner.OPTS) != null ? (ref13 = ref12.perTestOpts) != null ? ref13[this.cname] : void 0 : void 0, this.opts, {
            fail: fail // works but it's a different object
          });
          rv = _.bind(this)(this);
          if (V.type(rv) === "promise") {
            //						@lg "bagHandler returned Promise. Pushing..."
            a.push(new Promise((resolve2, reject2) => {
              return rv.then((resolved) => {
                //								@lg "FOUND RESOLVED PROMISE"
                afterHandler(fail);
                return resolve2(resolved);
              }).catch((ex) => {
                //								@lg "FOUND REJECTED PROMISE", ex
                afterHandler(fail);
                return reject2(ex);
              });
            }));
          } else {
            //						@lg "didn't return a promise"
            afterHandler(fail);
          }
        }
      }
      if (a.length > 0) {
        return Promise.all(a).then(() => {
          return resolve();
        }).catch((ex) => {
          this.logCatch("Promise.all", ex);
          return reject();
        });
      } else {
        return resolve();
      }
    });
    return PR.then(() => {
      var len1, len2, q, r, ref11, ref12, ref13, t, u;
      ref11 = this.failList;
      //			@lg "handlers all done"
      for (i = q = ref11.length - 1; q >= 0; i = q += -1) {
        fail = ref11[i];
        t = this.failTypes[fail.mFail];
        //			@lg "--> #{fail.one()} ==> #{t}" #, fail
        if (expectMap[t.toUpperCase()]) {
          //				@lg "EXPECT2: remove: i=#{i}"
          this.failList.splice(i, 1);
        }
      }
      if (this.bForcePass) {
        this.failList.length = 0;
      }
      if (this.failList.length) {
        console.log('-'.repeat(75));
        console.log(`${this.one()}: ${this.failList.length} RESIDUAL ERROR${(this.failList.length === 1 ? "" : "S")}`);
        console.log('-'.repeat(75));
        ref12 = this.failList;
        // @FAIL @FAIL_TIMEOUT, "[[#{@path}]] TO: ut.{resolve,reject} not called within #{ms}ms in asynch test"
        for (i = r = 0, len1 = ref12.length; r < len1; i = ++r) {
          fail = ref12[i];
          console.log(`SHORT: #${i + 1}  ${fail.one()}`);
        }
        ref13 = this.failList;
        for (u = 0, len2 = ref13.length; u < len2; u++) {
          fail = ref13[u];
          console.log("----------------------------------------------");
          console.log(Context.textFormat.red(S.prependPerLine("LONG: ", fail.full())));
        }
      } else if (!this.pass) {
        this.pass++;
      }
      return this.done();
    }).catch((ex) => {
      return this.logCatch("Test.after chain", ex);
    });
  }

  decorate() {
    var MAKE_UT_LOG_FAIL, j, len, mn, ref;
    this.assert(this.fn, "function body is required");
    this.assert = function(b, msg, v, opts) {
      var _;
      _ = msg ? `: ${msg}` : "";
      this.logSilent(`UT.docorate.assert: b=${b}${_}`, v, opts);
      if (b) {
        this.pass++;
      } else {
        this.FAIL(this.FAIL_ASSERT, `@assert${_}`, null, v, opts);
      }
      return b;
    };
    this.bag = proxyBag;
    this.context = "CONTEXT set in decorateJustObject"; //H
    this.defined = function(v, msg) {
      var _, b;
      _ = msg ? `: ${msg}` : "";
      this.logSilent(`defined: b=${b}${_}`);
      b = v != null;
      if (b) {
        //			log "defined"
        this.pass++;
      } else {
        this.FAIL(this.FAIL_ASSERT, _, null, null);
      }
      return b;
    };
    this.delay = function(ms) {
      var to;
      to = {
        ms: ms,
        msActual: null,
        msBeg: Date.now(),
        msEnd: null
      };
      return new Promise((resolve) => { //NEEDED
        this.logg(trace.DELAY, `delay ${ms}`);
        return setTimeout(() => {
          to.msEnd = Date.now();
          to.msActual = to.msEnd - to.msBeg;
          //						@logg trace.DELAY_END, "END: delay #{ms} *^20", to
          return resolve(to);
        }, ms);
      });
    };
    this.eq = function(a, b, msg, o) {
      return this.eqINNER.apply(this, [
        "eq",
        ...arguments //PATTERN #FORWARD #CURRYING #INJECT-ONE #ADD-ONE
      ]);
    };
    this.Eq = function(a, b, msg, o) {
      return this.eqINNER.apply(this, ["Eq", ...arguments]);
    };
    this.EQ = function(a, b, msg, o) {
      return this.eqINNER.apply(this, ["EQ", ...arguments]);
    };
    this.EQO = function(a, b, msg, o) {
      return this.eqINNER.apply(this, ["EQO", ...arguments]);
    };
    this.eqINNER = (mn, a, b, msg, o) => {
      var doValue, report, s;
      //							PASS CRITERIA
      // eq	#EQ-NOT-STRICT		"as string equal"		(new String "6") eq 6
      // Eq	#EQ-MID-STRICT		"value not type"		(new String "6") Eq "6"						#H: same as eq?
      // EQ	#EQ-STRICT			"value and type"		(new String "6") EQ (new String "6")
      // EQO	#EQ-SAME			"same object"			obj == obj

      //CRASH: TypeError: Cannot convert object to primitive value
      this.lg(`${mn}: BEG: a=${a} b=${b}`);
      if (!(a != null) && !(b != null)) {
        this.logg(trace.UT_EQ, `${mn} pass: ${a} vs ${b}: both undefined [${msg}]`, o);
        return true;
      }
      s = ""; // method passes if nothing appended
      doValue = () => {
        var aa, c, i, j, len;
        a = "" + a;
        b = "" + b;
        //				console.log "------------"			#DEBUGGING
        //				console.log "aaa> #{a}"
        //				console.log "bbb> #{b}"
        if (b.includes('*')) {
          // mask asterisks(*) in the LEFT string if they are present in the RIGHT string
          aa = "";
          for (i = j = 0, len = b.length; j < len; i = ++j) {
            c = b[i];
            //					@lg c
            if (c === '*') {
              aa += '*';
            } else {
              //						console.log "MASK!"
              aa += i < a.length ? a[i] : '';
            }
          }
          a = aa;
        }
        //					console.log "aaa> #{a}"
        //					console.log "bbb> #{b}"
        if (!V.EQ(a, b)) {
          return s = `${mn} values violation`;
        }
      };
      switch (mn) {
        case "eq":
          doValue();
          break;
        case "Eq":
          doValue();
          break;
        case "EQ":
          if (V.Type(a) !== V.Type(b)) {
            s = "types violation";
          } else {
            doValue();
          }
          break;
        case "EQO":
          if (a !== b) {
            s = "EQO not same object";
          }
      }
      if (s) {
        s += `\na> ${V.vt(a)}\nb> ${V.vt(b)}`;
        report = V.COMPARE_REPORT(a, b);
        this.FAIL(this.FAIL_EQ, `${mn} ${a} vs. ${b}${AP.c_d(msg)}`, `${s}${AP.crlf_d(report)}`, o);
        this.logg(trace.UT_EQ, `${mn} ${textFormat.red("fail")}: ${a} vs ${b} [${msg
        //RENAME: EQ
}]`);
        return false;
      } else {
        this.logg(trace.UT_EQ, `${mn} pass: ${a} vs ${b}${SP.sq(msg)}`);
        this.logSilent(`inside ${mn}: PASS: ${msg}`, o);
        this.logSilent(V.vt(a));
        this.logSilent(V.vt(b));
        this.pass++;
        this.logSilent(`${mn}: pass=${this.pass}`);
        return true;
      }
    };
    this.eqfile = async function(a, b) { //CONVENTION
      var _a, _b;
      //EQ-FILE-CONTENTS: "file contents"	path eqfile path
      this.lg(`a: ${a}`);
      this.lg(`b: ${b}`);
      _a = (await this.file.fileSize(a));
      if (_a < 0) {
        this.lg("a dne");
        return this.FAIL(this.FAIL_EQ, "eq \"doesn't exist\" vs. \"b\"", `a=${a}`);
      }
      _b = (await this.file.fileSize(b));
      if (_b < 0) {
        this.lg("b dne");
        return this.FAIL(this.FAIL_EQ, "eq \"a\" vs. \"doesn't exist\"", `b=${b}`);
      }
      return this.eq(_a, _b);
    };
    this.ex = function(ex) { //OPPO: @ok
      this.logCatch(ex);
      return this.reject(ex);
    };
    this.FAIL = function(mFail, summary, detail, v, opts) {
      var _, fail;
      if (!mFail) {
        throw Error("bad mFail");
      }
      if (!IS.n(mFail)) {
        //REVISIT
        this.lg(`@FAIL: p0: mFail: isn't n (got: ${IS.ty(mFail)})`);
      }
      if ((summary != null) && !IS.s(summary)) {
        this.lg(`@FAIL: p1: summary: isn't s (got: ${IS.ty(summary)})`);
      }
      if ((detail != null) && !IS.s(detail)) {
        this.lg(`@FAIL: p2: detail: isn't s (got: ${IS.ty(detail)})`);
      }
      if (typeof v !== "object") {
        this.lg(`@FAIL: p3: v: isn't v (got: ${IS.ty(v)})`);
      }
      if ((opts != null) && !IS.opts(opts)) {
        this.lg(`@FAIL: p4: opts: isn't opts (got: ${IS.ty(opts)})`);
      }
      //			console.log "\n\n\nX X X X X X X X X"		#POP
      fail = new this.Fail(mFail, summary, detail, v, opts);
      //			@lg "TYPE: #{Context.TYPE v}"
      _ = `FAIL: ${IF(summary, `${summary}: `)}fail666=${this.failList.length}`;
      if (v) {
        //				Context.O.DUMP v
        if (typeof v === "object") {
          //					console.log "a"
          this.lg(_, v);
        } else {
          if (IS.ml(v)) {
            this.lg(_);
            console.log("multi-line dump:");
            console.log(v);
          } else {
            this.lg(`${_}: ${v}`);
          }
        }
      } else {
        this.lg(_);
      }
      if (this.runner.OPTS.mFailMode === this.FM_FAILFAST) {
        log(fail.full());
        this.exit(this.WHY_FAIL_FAST, summary);
        log(this.one());
        abort(`FM_FAILFAST: ${_}`);
      }
      return false;
    };
    this.fatal = function(msg) {
      console.error(`fatal: ${msg}`);
      this.exit(this.WHY_FATAL, msg);
      return abort(msg);
    };
    this.h = function(s) {
      return this.log(s, void 0, {
        bHeader: false,
        format: "blue,bold,uc",
        orTrace: "H"
      });
    };
    //DUP: this is principal @log of unit tests		
    this.log = function(sU, oU, opts) {
      var bbb;
      if (opts != null ? opts.orTrace : void 0) {
        //				log "OR TRACE: #{opts.orTrace}"
        bbb = trace[opts.orTrace];
      }
      //				console.log "bbb => #{bbb}"
      //				console.log "SUMMARY=#{trace.summary()}"
      //			console.log bbb
      if (trace.UT || bbb) {
        return Context.logBase.apply(this, [
          `${this.cname}/${this.tn}`,
          ...arguments //PATTERN: CALL #FORWARD
        ]);
      }
    };
    this.m = (s) => {
      this.markers += s;
      return this.log(`MARK ${s}`, void 0, {
        bHeader: false,
        format: "magenta,bold,uc"
      });
    };
    MAKE_UT_LOG_FAIL = (mn, mFail) => {
      return ((mn, mFail, t) => { //PATTERN #CURRYING
        //				console.log "mn=#{mn} mFail=#{mFail}"
        return t[mn] = function(msg, o, opt) {
          this.lg(`method ${mn}: ${kvt("msg", msg)}`);
          this.lg(`FFF8: MAKE_UT_LOG_FAIL '${mn}'`);
          //					if V.type(msg) is "string"
          if (IS.s(msg)) {
            //						(mFail, summary, detail, v)
            return this.FAIL(mFail, msg, "", o, opt);
          } else {
            o = msg;
            opt = o;
            msg = "";
            return this.FAIL(mFail, msg, "UT~MAKE_UT_LOG_FAIL", o, opt); //H:opt #EXTRA_PARAM
          }
        };
      })(mn, mFail, this);
    };
    MAKE_UT_LOG_FAIL("logCatch", this.FAIL_EXCEPTION);
    MAKE_UT_LOG_FAIL("logError", this.FAIL_ERROR);
    this.mStage = this.STAGE_SETUP;
    this.ok = function(vOpt) { //CONVENTION		#OPPO: @ex
      //		drill this, grep:"env"
      this.lg("OK", this.env);
      //		@env.succ()		
      return this.resolve(vOpt);
    };
    this.PASS = function() {
      return this.bForcePass = true;
    };
    this.PASS_CNT = function(n = 1) {
      return this.pass += n;
    };
    this.throw = function(msg) {
      throw Error(msg); //USED?
    };
    
    //H: what is this?  write test for it
    // I JUST DO NOT UNDERSTAND THIS!
    // in ServerStoreUT it moves alloc() to be reachable from unit test
    if (this.common) {
      ref = this.common;
      //			@lg "common: #{JSON.stringify @common}"
      for (j = 0, len = ref.length; j < len; j++) {
        mn = ref[j];
        //				log "found common routine: #{mn}"
        if (this[mn]) {
          //					console.log "@common:"
          //					O.LOG @common
          throw Error(`UT003 You are not allowed to define the method named '${mn}' because it clashes with a built-in property`);
        }
        this[mn] = this.parent[mn];
      }
    }
    return this.fn.bind(this);
  }

  // ################### end of decorate ###################
  done(who) {
    syncTestsCount--;
    //		@lg "DONE DONE DONE DONE DONE: Test.done: #{@one2()}"
    Base.auditEnsureClosed("Test.done");
    //		abort()
    this.auditMark("" + this.one2());
    if (this.mState !== this.STATE_RUNNING) {
      throw Error(`done: who=${who}: mState: expected=${this.stateFrag(this.STATE_RUNNING)} got=${this.stateFrag()}`);
    }
    this.mState = this.STATE_DONE;
    this.msEnd = Date.now();
    this.msDur = this.msEnd - this.msBeg;
    if (this.opts.bTraceRecommended) {
      //			hr
      trace.stackAllPop();
    }
    
    //		@logg trace.UT_DUR, "dur=#{@msDur}: #{@path}"
    //		@lg "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ post: who=#{who} ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

    //		if Base.openCntGet()
    //			Base.logOpenMap()
    //			@stack()
    //			abort "INTERMEDIATE RESOURCES LEFT OPEN!"
    this.eventFire("test-done");
    return this.runner.testDone(this);
  }

  enable() {
    this.bEnabled = true;
    this.mStage = this.STAGE_SETUP;
    return this.mState = this.STATE_WAITING;
  }

  //		@lg "enable: #{@one2()}"

  //  	delegate to runner
  eventFire(eventName, msg) {
    return this.runner.eventFire(eventName, msg != null ? msg : this.cmd, this, this.opts);
  }

  //	Test.exit
  exit(mWhy, msg) {
    return this.runner.exit(mWhy, msg);
  }

  isAsyncRunnable() {
    return false;
  }

  // 	Test.start()
  start() {
    var k, pn, pv, ref, ref1, ref2, ref3, ref4, v;
    this.opts = Object.assign({}, this.runner.OPTS, (ref = this.runner.OPTS) != null ? (ref1 = ref.perTestOpts) != null ? ref1[this.cname] : void 0 : void 0, this.opts);
    delete this.opts.perTestOpts; //H: this assumes PER TEST not PER FILE
    
    //		@log "@runner.OPTS", @runner.OPTS
    //		@log "START", @opts
    if (this.opts.bTraceRecommended) {
      //			@log "opts", @opts
      trace.stackAllPush(this.opts.ty);
    }
    //			@log "@opts.ty -> #{@opts.ty}", trace.one()
    this.logg(trace.UT_TEST_PRE_ONE_LINER, `^=^20 ${this.one()}`, void 0, {
      format: "yellow" // /#{g_testList.length} #{@cname} #{@cmd}:#{@tn}#{AP.c_d trace.DETAIL, "path=#{@path}"}"
    });
    global.tn = this.tn;
    //		@log "tn=#{@tn}"
    this.msBeg = Date.now();
    this.mState = this.STATE_RUNNING;
    syncTestsCount++;
    ref2 = this.parent;
    for (k in ref2) {
      v = ref2[k];
      this[k] = v;
    }
    ref4 = (ref3 = this.opts.decorate) != null ? ref3.test : void 0;
    for (pn in ref4) {
      pv = ref4[pn];
      //			console.log "decorate?.test: #{pn}"
      this[pn] = pv;
    }
    /*
    		testThis = Object.assign {}, @parent
    RN:
    TypeError: One of the sources for assign has an enumerable key on the prototype chain. Are you trying to assign a prototype property? We don't allow it, as this is an edge case that we do not support. This error is a performance optimization and not spec compliant.
    */
    this.fnTest = this.decorate();
    this.eventFire("test-start");
    return Base.UT_OWNER = this.one2();
  }

  //	Test.exit()		#DELEGATE
  exit(mWhy1, msg) {
    this.mWhy = mWhy1;
    //		log "Test.exit called"
    return this.runner.exit.apply(this.runner, arguments); //PATTERN: PROXY propagate arguments	
  }

  optsValidate() {
    var cmd, cmds, j, k, len, ref, ref1;
    if (this.opts) {
      //			@lg "opts", @opts			#RN #POP
      if (this.opts.exceptionMessage && (this.opts.expect == null)) {
        this.opts.expect = "EXCEPTION";
      }
      cmds = "bManual,desc,exceptionMessage,expect,hang,markers,mkr,mType,mutex,onAssert,onEq,onError,onException,onTimeout,onUnfail,onUnexpectedPromise,SO,RUNTIME_SECS,tags,timeout,tru,ty,url,USER_CNT".split(',');
      for (j = 0, len = cmds.length; j < len; j++) {
        cmd = cmds[j];
        //			for cmd in cmds
        //				console.log "_t \"#{cmd}\", (ut) ->"
        cmds.push('_' + cmd);
      }
      for (k in this.opts) {
        if (indexOf.call(cmds, k) < 0) {
          this.logFatal(`[[${this.path}]] UT001 Unknown test option: '${k}'`, cmds, {
            bTable: true
          });
        }
      }
      if ((this.opts.onTimeout || this.opts.timeout) && ((ref = this.cmd) !== "_a" && ref !== "a" && ref !== "_A" && ref !== "A" && ref !== "_p" && ref !== "p" && ref !== "_P" && ref !== "P")) {
        this.logFatal(`[[${this.path}]] UT008 asynch opt not allowed with '${this.cmd}' cmd`, this.opts);
      }
      if (this.opts.mType != null) {
        //				@lg "opts.mType=#{@opts.mType}"
        if ((0 <= (ref1 = this.opts.mType) && ref1 <= 1)) {
          return this.runner.mTypeCtrList[this.opts.mType]++;
        } else {
          return this.logFatal(`[[${this.path}]] UT002 Unknown mType=${this.opts.mType}`, this.opts);
        }
      }
    }
  }

};

//END:Test
SyncTest = class SyncTest extends Test { //@SyncTest @sync
  constructor(optsOrig) {
    super(optsOrig, {
      bSync: true,
      bWasException: false //R: move to Test and get rid of altogether
    });
  }

  
  // 	SyncTest.start()
  start() {
    var ex, rv;
    super.start();
    try {
      rv = this.fnTest(this); // SYNC
    } catch (error) {
      ex = error;
      this.lg("sync had exception");
      return this.after(this.FAIL_EXCEPTION, ex);
    }
    if (IS.pr(rv)) {
      return this.after(this.FAIL_UNEXPECTED_PROMISE, rv);
    } else {
      return this.after(null, null);
    }
  }

};

AsyncTest = (function() {
  //END:SyncBase
  class AsyncTest extends Test { //@AsyncTest @async
    static s_one() {
      return `${AsyncTest.s_mutexDump()} (${AsyncTest.s_mutexCnt()})`;
    }

    static s_mutexCnt() {
      return O.CNT_OWN(AsyncTest.s_mutexMap);
    }

    static s_mutexDump() {
      return Object.getOwnPropertyNames(AsyncTest.s_mutexMap).sort().join(',');
    }

    constructor(optsOrig) {
      super(optsOrig, {
        bSync: false
      });
    }

    // 	AsyncTest.start()
    start() {
      var timer;
      super.start();
      if (this.opts.mutex) {
        AsyncTest.s_mutexMap[this.opts.mutex] = true;
      }
      timer = null;
      return new Promise((resolve1, reject1) => {
        var ex, ms, rv;
        this.resolve = resolve1;
        this.reject = reject1;
        ms = this.opts.hang ? 2147483647 : this.opts.timeout;
        //			@lg "setting timer: #{ms}ms"
        timer = setTimeout(() => {
          this.log("ASYNC TO!");
          return this.after(this.FAIL_TIMEOUT, ms); // promise is never consummated and that's okay
        }, ms);
        try {
          rv = this.fnTest(this); // ASYNC
        } catch (error) {
          ex = error;
          //				console.log "catch: asynch test"
          clearTimeout(timer);
          //YES_CODE_PATH: I've seen this but sure why... you'd think that "catch" would be run instead
          //				throw new Error "REALLY?  I really don't see how this could be triggered"  it's not a promise... it's  TRY..CATCH... that's why!
          this.lg("FFF1");
          return this.after(this.FAIL_EXCEPTION, ex);
        }
        this.lg(`returned from asynch test! ${kvt("rv", rv)}`);
        if (this.cmd.toLowerCase() === 'p') {
          this.lg(kvt(`${this.cmd}-test rv`, rv));
          if (IS.pr(rv)) {
            //					@lg "async test returned Promise"
            return rv.then((resolved) => {
              clearTimeout(timer);
              this.lg(`FFF2: @p ut return value: promise, that is NOW resolved: ${LL.PR_RESOLVED(resolved)}`);
              return this.after(null, null);
            }).catch((ex) => {
              clearTimeout(timer);
              this.lg(`FFF3: @p ut return value: promise, that is NOW rejected: ${LL.PR_REJECTED(ex)}`);
              return this.after(this.FAIL_EXCEPTION, ex);
            });
          } else {
            clearTimeout(timer);
            //					@lg "SHOULD HAVE BEEN PROMISE", rv
            this.lg("FFF4");
            return this.after(this.FAIL_ERROR, "UT004 Promise expected but not returned from P-test");
          }
        } else {
          if (IS.pr(rv)) {
            if (trace.TIP) {
              this.logWarning("tip: async test returned a promise; consider using @p instead of @a");
            }
            return rv.then((v) => {
              if (this.mState !== this.STATE_DONE) {
                this.lg(`[${this.STATE_LIST[this.mState]}] one3=${this.one3()}`);
                return this.lg(`[${this.STATE_LIST[this.mState]}] @a returned promise. WHAT DO? resolved value=`, v);
              }
            }).catch((ex) => {
              //						@logCatch "@a returned promise. WHAT DO? rejected value=", ex
              clearTimeout(timer);
              this.lg("FFF5");
              return this.after(this.FAIL_EXCEPTION, ex);
            });
          } else {
            this.lg("AsyncTest.start: non-promise return value from @a.  rv=", rv);
            this.lg(`AsyncTest.start: typeof(rv)=${typeof rv}`);
            this.lg(`AsyncTest.start: Context.IS.who=${Context.IS.who(rv)}`);
            return this.logSilent("non-promise return value from @a.  rv=", rv);
          }
        }
      }).then((resolved) => {
        this.logg(trace.UT_RESOLVE_REJECT_VALUE, "RESOLVED:", resolved); //NEEDS-LOVE
        clearTimeout(timer);
        this.lg(`FFF6: ut ITSELF resolved promise: ${LL.PR_RESOLVED(resolved)}`);
        return this.after(null, null);
      }).catch((ex) => {
        this.logg(trace.UT_RESOLVE_REJECT_VALUE, "REJECTED:", ex);
        clearTimeout(timer);
        this.lg("FFF7");
        return this.after(this.FAIL_EXCEPTION, ex);
      });
    }

    isAsyncRunnable() {
      //		O.LOG "OPTS", @runner.OPTS
      if (this.bSync) {
        return false;
      //		else if @runner.OPTS.bSerial
      //			# force serial
      //			_ = O.EMPTY_OWN(AsyncTest.s_mutexMap)
      //#			@lg "force serial: #{_}"
      //			_
      } else if (this.opts.mutex) {
        return !AsyncTest.s_mutexMap[this.opts.mutex];
      } else {
        //			@lg "isAsyncRunnable: true (no mutex)"
        return true;
      }
    }

    done() {
      super.done();
      if (this.opts.mutex) {
        return delete AsyncTest.s_mutexMap[this.opts.mutex];
      }
    }

  };

  AsyncTest.s_mutexMap = {}; //STATIC

  return AsyncTest;

}).call(this);

//END:AsyncTest
Section = class Section extends Base { //@Section
  constructor() {
    super();
  }

};

//END:Section
syncTestsCount = 0; //HACK

UTRunner = class UTRunner extends UTBase { //@UTRunner @runner
  constructor(argv = ["", ""], opts1 = {}, cb = (function() {})) {
    var base, base1, ref;
    super("I DO NOT UNDERSTAND WHY I CANNOT PASS @__CLASS_NAME and I don't know why it works when I don't");
    this.argv = argv;
    this.opts = opts1;
    this.cb = cb;
    //		log "UT CONSTRUCTOR IMPLICIT CALL: #{@WORK_AROUND_UT_CLASS_NAME_OVERRIDE} #{@constructor.name}"
    //		O.LOG @opts
    this.OPTS = this.opts; //HACK
    if ((base = this.OPTS).bOnline == null) {
      base.bOnline = true;
    }
    if ((base1 = this.OPTS).timeout == null) {
      base1.timeout = 3000;
    }
    O.validate(this.opts, {
      onlyCSV: "bOnline,bSerial,decorate,mFailMode,perTestOpts,timeout,userDefined"
    });
    //		console.log "UT.UTRunner.constructor: WORK_AROUND_UT_CLASS_NAME_OVERRIDE=#{@WORK_AROUND_UT_CLASS_NAME_OVERRIDE}"
    //		console.log "UT.UTRunner.constructor: constructor.name=#{@constructor.name}"
    this.__CLASS_NAME = (ref = this.WORK_AROUND_UT_CLASS_NAME_OVERRIDE) != null ? ref : this.constructor.name;
    //INIT
    this.bRunning = true;
    this.failList = [];
    this.mTypeCtrList = [0, 0];
    this.runningCnt = 0;
    this.pass = 0;
    this.selectList = [];
    this.runnerThread = null;
    //MOVE
    Object.defineProperties(this, {
      UT: {
        enumerable: true,
        get: function() {
          return trace.UT;
        },
        set: function(v) {
          //					console.log "set T=#{v}"
          return trace.UT = v;
        }
      }
    });
  }

  CLI(a) {
    var ADDTEST, CLIParser, CSV, CSV2Object, NUMBER_CSL_RE, UniqueTester, _, aMod, bActed, bHELP, dupMap, er, getKeys, i, j, l, len, len1, len2, len3, len4, log_help, maybeGrabTrace, monUnique, optRec, optionList, optionalNumber, p, parser, q, r, setTrace, sum, test, testPattern, tn, traceList, word;
    optionList = [
      {
        //EASY 
        /*
          -o		"g"														the actual ASCII option minus the dash
          -n		"grep tests"											the short name (title)
          -u		"pattern"												use to manufactor "-g pattern"
          -d		"list tests that match grep pattern"					short sentence description
          -s		"The g option greps the name and description..."		multi-line description
        */
        o: "-a",
        d: "force all tests to be run (ignore individual test overrides)"
      },
      {
        o: "-async",
        d: "only asychronous tests"
      },
      {
        o: "-c ServerStoreUT",
        d: "run all tests of a specified class (FUTURE)"
      },
      {
        o: "-dup",
        d: "display duplicate test names"
      },
      {
        o: "-eg key1,key2,...",
        d: "exit grep"
      },
      {
        o: "-ex",
        d: "cli EXamples"
      },
      {
        o: "-f FM#",
        d: "mFailMode: 0=fail fast, 1=fail after test, 2=run all"
      },
      {
        o: "-g testPattern",
        d: "like -l (list all tests) but only show matching lines"
      },
      {
        o: "-h",
        d: "help"
      },
      {
        o: "-i",
        d: "ignore test#,test#,..."
      },
      {
        o: "-l",
        d: "list all tests"
      },
      {
        o: "-lg key1,key2,...",
        d: "log grep"
      },
      {
        o: "-lh key1,key2,...",
        d: "log highlight"
      },
      {
        o: "-llh key1,key2,...",
        d: "log line highlight (FUTURE)"
      },
      {
        o: "-mkr pattern",
        d: "discover and list all test monikers"
      },
      {
        o: "-o",
        d: "offline"
      },
      {
        o: "-r test#",
        d: "recursive test given a section # (FUTURE)"
      },
      {
        o: "-s",
        d: "run the tests in a serial manner, one after another"
      },
      {
        o: "-sum",
        d: "display just the summary"
      },
      {
        o: "-sync",
        d: "only sychronous tests"
      },
      {
        o: "-t",
        d: "Trace: per-test pre-specified CSV passed via -ty flag",
        impl: "bTraceRecommended=true"
      },
      {
        o: "-tagn",
        d: "exclude tag1,tag2,... (FUTURE)"
      },
      {
        o: "-tagy",
        d: "include tag1,tag2,,... (FUTURE)"
      },
      {
        o: "-tl",
        d: "trace list"
      },
      {
        o: "-tg",
        d: "trace grep"
      },
      {
        o: "-tn",
        d: "Trace No: turn off all trace"
      },
      {
        o: "-ty",
        d: "Trace Yes: turn on all trace: naked or -ty ut,... for trace.UT (\"log tests\")", //DOMAIN-SPECIFIC #MOVE #H
        ex: "-ty backronym,retronym"
      }
    ];
    for (j = 0, len = optionList.length; j < len; j++) {
      optRec = optionList[j];
      O.validate(optRec, {
        onlyCSV: "o,d,ex,impl"
      });
    }
    this.eventFire("CLI-optionList", optionList);
    optionList.sort(function(a, b) {
      if (a.o > b.o) {
        return 1;
      } else {
        return -1;
      }
    });
    CSV2Object = (key) => {
      var _, k, keys, l, len1, ref, results;
      //			console.log "CSV2Object: global.#{key}"
      if (i < a.length) {
        if (/^[\$\.0-9a-zA-Z_]+(,[\$\.0-9a-zA-Z_]+)*$/.test((keys = a[i++]))) {
          
          //					@lg "keys=#{keys}"
          global[key] = this.OPTS[key] = _ = {};
          ref = keys.split(',');
          results = [];
          for (l = 0, len1 = ref.length; l < len1; l++) {
            k = ref[l];
            _[k.toUpperCase()] = true;
            results.push(console.log(`CSV2Object: global[${key}][${k.toUpperCase()
          //C
}] = true`));
          }
          return results; //R
        } else {
          //					@lg "CSV2Object @OPTS[#{key}]=", _
          return er(`UT: ${a[i - 2]}: argument isn't in correct comma-separated format: ${keys}`);
        }
      } else {
        return er(`UT: ${a[i - 1]}: must specify comma-separated keywords`);
      }
    };
    er = (msg) => {
      if (msg) {
        console.log(msg);
      }
      return this.exit(this.WHY_CLI);
    };
    
    //GITHUB: remove all trace references?
    maybeGrabTrace = (v) => {
      if (i < a.length && trace.RE_CSV.test(a[i])) {
        setTrace(a[i++], v);
        return true;
      } else {
        return false;
      }
    };
    optionalNumber = function(def) {
      if (i < a.length && /^[0-9]+$/.test(a[i])) {
        i++;
        return a[i - 1] * 1; //PATTERN
      } else {
        return def;
      }
    };
    setTrace = function(csv, v) {
      trace[csv] = v;
      //			console.log "UT: trace.one: #{trace.one()}"
      //			O.DUMP trace
      //			drill trace
      return trace;
    };
    traceList = (pattern) => {
      var depth, k, l, last, len1, ref;
      depth = 0;
      last = 'A';
      ref = Object.keys(trace).sort();
      for (l = 0, len1 = ref.length; l < len1; l++) {
        k = ref[l];
        if (k[0] !== last) {
          last = k[0];
          depth++;
        }
        if (!pattern || k.includes(pattern.toUpperCase())) {
          console.log(`${" ".repeat(depth * 5)}${k}`);
        }
      }
      return this.exit(this.WHY_CLI);
    };
    getKeys = (bEnable) => {
      var _, k, keys, l, len1, ref;
      if (i < a.length) {
        if (/^[a-zA-Z_]+(,[a-zA-Z_]+)*$/.test((keys = a[i++]))) {
          _ = {};
          ref = keys.split(',');
          for (l = 0, len1 = ref.length; l < len1; l++) {
            k = ref[l];
            _[k.toUpperCase()] = true;
          }
          this.OPTS["keys" + bEnable] = _;
          return O.LOG(this.OPTS);
        } else {
          return er("UT: keys must be comma-delimited");
        }
      } else {
        return er("UT: missing comma-delimited set of keys");
      }
    };
    log_help = () => {
      return console.log(`node tests.js [options] test# ...\n\n${S.autoTable(optionList, {
        headerMap: {
          o: "option",
          d: "description",
          impl: "internals",
          ex: "example"
        }
      })}`);
    };
    CSV = "testIndex,cmd,path,optsCSV,tagsCSV";
    NUMBER_CSL_RE = /^\d+(,\d+)*$/;
    CLIParser = class CLIParser extends Base {};
    parser = new CLIParser();
    UniqueTester = class UniqueTester {
      constructor(bCaseSensitive, fnClash) {
        this.bCaseSensitive = bCaseSensitive;
        this.fnClash = fnClash;
        this.map = Object.create(null);
      }

      add(item) {
        if (item) {
          if (!this.bCaseSensitive) {
            item = item.toUpperCase();
          }
          if (this.map[item]) {
            return this.fnClash(item);
          } else {
            //						console.log "OKAY: #{item}"
            return this.map[item] = true;
          }
        }
      }

    };
    monUnique = new UniqueTester(false, (item) => {
      return this.logError(`monikers ('${item}') must be unique`);
    });
//		monUnique.add "peter"
//		monUnique.add "peter"
    for (l = 0, len1 = g_testList.length; l < len1; l++) {
      test = g_testList[l];
      //			@log test.mkr
      monUnique.add(test.mkr); //? test.tn
    }
    i = 0;
    while (i < a.length) {
      word = a[i++];
      parser.word = word;
      bActed = this.eventFire("CLI-flag", parser);
      if (!bActed) {
        switch (word) {
          case "-a":
            this.OPTS.testsAll = true;
            break;
          case "-async":
            this.OPTS.bAsync = true;
            break;
          case "-dup":
            // O.DUMP g_testList
            dupMap = {};
            for (p = 0, len2 = g_testList.length; p < len2; p++) {
              test = g_testList[p];
              if (!dupMap[test.tn]) {
                dupMap[test.tn] = [];
              }
              dupMap[test.tn].push({
                cn: test.cn,
                path: test.path
              });
            }
            for (tn in dupMap) {
              a = dupMap[tn];
              if (a.length > 1) {
                this.box(tn);
                er(S.autoTable(a, {
                  bHeader: true,
                  includeCSV: CSV
                }));
              }
            }
            break;
          case "-f":
            this.OPTS.mFailMode = optionalNumber(1);
            break;
          case "-g":
            testPattern = a[i++];
            er(S.autoTable(g_testList, {
              bHeader: true,
              grep: testPattern,
              includeCSV: CSV
            }));
            break;
          case "-eg":
            CSV2Object("exitCSV");
            break;
          case "-h":
            er(log_help());
            break;
          case "-i":
            word = a[i++];
            if (NUMBER_CSL_RE.test(word)) {
              this.OPTS.testsIgnore = word;
            } else {
              er(`UT: Illegal -i parameter: "${word}".  Must be #,#,...`);
            }
            break;
          case "-kn":
            getKeys(false);
            break;
          case "-ky":
            getKeys(true);
            break;
          case "-l":
            er(S.autoTable(g_testList, {
              bHeader: true,
              includeCSV: CSV
            }));
            break;
          case "-lg": //MOVE: tests
            this.OPTS.logGrepPattern = a[i++];
            break;
          case "-lh": //MOVE: tests
            CSV2Object("logHighlightPattern");
            break;
          case "-mkr":
            testPattern = a[i++];
            aMod = [];
            for (q = 0, len3 = g_testList.length; q < len3; q++) {
              test = g_testList[q];
              if (test.mkr) {
                aMod.push({
                  testIndex: test.testIndex,
                  mkr: test.mkr,
                  tn: test.tn
                });
              }
            }
            aMod.sort(function(a, b) {
              if (a.mkr < b.mkr) {
                return -1;
              } else {
                return +1;
              }
            });
            er(S.autoTable(aMod, {
              bHeader: true,
              boldColumnMap: {
                mod: true
              },
              grep: testPattern
            }));
            break;
          case "-o":
            this.OPTS.bOnline = false;
            break;
          case "-s":
            this.OPTS.bSerial = true;
            break;
          case "-sum":
            //						@OPTS.bSummary = true
            //H: somehow se trace.UT_TEST_PRE_ONE_LINER = false (set in tests: "runner-start")
            bHELP = true;
            break;
          case "-sync":
            this.OPTS.bSync = true;
            break;
          case "-t":
            this.OPTS.bTraceRecommended = true;
            break;
          //						if i < a.length and trace.RE_CSV.test a[i]
          //							@OPTS.bTraceRecommended = a[i++]
          case "-tg":
            traceList(a[i++]);
            break;
          case "-tl":
            traceList(null);
            break;
          case "-tn":
            if (!maybeGrabTrace(false)) {
              this.OPTS.traceOverride = false;
            }
            break;
          case "-ty":
            if (!maybeGrabTrace(true)) {
              this.OPTS.traceOverride = true;
            }
            break;
          default:
            ADDTEST = (word) => {
              //							@log "ADDTEST: #{word}"
              if (this.OPTS.testsInclude) {
                return this.OPTS.testsInclude = this.OPTS.testsInclude + "," + word;
              } else {
                return this.OPTS.testsInclude = "" + word;
              }
            };
            if (NUMBER_CSL_RE.test(word)) {
              ADDTEST(word);
            } else {
              // map monikers to IDs
              //							@log "g_testList", g_testList
              //							for test in g_testList
              //#								@log "tn=#{test.tn} mkr=#{test.mkr} opts.mkr=#{test.opts.mkr}"		#, test.opts
              //#								@log "tn=#{test.tn} opts.mkr=#{test.opts.mkr}"
              //								if test.tn is "cat2"
              //#									@log "MON: #{test.opts.mkr ? test.tn}"
              //#									@log "tn=#{test.tn} mkr=#{test.mkr}"	# , test.opts
              //									@log "tn=#{test.tn} mkr=#{test.mkr}"	# , test.opts
              _ = g_testList.filter(function(test) {
                var ref, ref1;
                return ((ref = (ref1 = test.mkr) != null ? ref1.toUpperCase() : void 0) != null ? ref : test.tn.toUpperCase()) === word.toUpperCase();
              });
              if (_.length) {
                //								@log "found #{word} => #{_[0].testIndex}"
                ADDTEST(_[0].testIndex);
              } else {
                log_help();
                if (word[0] === '-') {
                  er(`UT: Illegal CLI option: "${word}".`);
                } else {
                  er(`UT: Illegal moniker (doesn't match test.tn or test.opts.mkr): "${word}".`);
                  this.log("EXTRA", word);
                }
              }
            }
        }
      }
    }
    sum = 0;
    if (this.selectList.length > 0) {
      sum++;
    }
    if (this.OPTS.testsAll) {
      sum++;
    }
    if (this.OPTS.bAsync) {
      sum++;
    }
    if (this.OPTS.bSync) {
      sum++;
    }
    //		@lg "sum=#{sum}"
    if (sum > 1) {
      er("Can't specify #, -a, -async, -sync at the same time");
    }
    //		if @OPTS.bSummary?
    //			trace.summary()		#WTF: commenting this out b/c it makes no sense at all

    //		if @OPTS.traceOverride?
    //			console.log "calling TRISTATE"
    //			trace.tristate @OPTS.traceOverride
    //		@lg "CLI", @OPTS

    //		if @OPTS.mFailMode is @FM_FAILFAST			#POP
    //			trace.tristate t r u e
    if (this.OPTS.bSerial != null) {
      for (r = 0, len4 = g_testList.length; r < len4; r++) {
        test = g_testList[r];
        if (!test.opts) {
          console.log("falsy test.opts");
          O.LOG(test);
        }
        test.opts.mutex = "same";
      }
    }
  }

  count(mState) {
    var count, j, len, test;
    this.assert((this.STATE_WAITING <= mState && mState <= this.STATE_DONE));
    count = 0;
    for (j = 0, len = g_testList.length; j < len; j++) {
      test = g_testList[j];
      if (test.mState === mState) {
        //			@lg "COUNT", test
        count++;
      }
    }
    //		@lg "count[#{mState}] => #{count}"
    return count;
  }

  eventFire(eventName, primative, test, opts) {
    var _opts;
    _opts = opts != null ? opts : this.OPTS;
    if (!this.bRunning && eventName !== "runner-done") {
      return;
    }
    //			console.log "shutting down is discard most events"
    this.cb(eventName, primative, test, _opts, this);
    this.onEvent(eventName, primative, test, _opts);
    switch (eventName) {
      case "CLI-optionList":
        return this.onEventCLIOptionList(primative, _opts);
      case "CLI-flag":
        return this.onEventCLIFlag(primative, _opts);
      case "left-open":
        return this.onEventLeftOpen(primative, _opts);
      case "runner-done":
        return this.onEventRunnerDone(primative, _opts);
      case "runner-start":
        return this.onEventRunnerStart(primative, _opts);
      case "test-done":
        return this.onEventTestDone(primative, test, _opts);
      case "test-start":
        return this.onEventTestStart(primative, test, _opts);
    }
  }

  //			else
  //				throw Error "UT004 EVENT NOT HANDLED: eventName=#{eventName}: Did subclass override methods pass all parameters to super.onEvent?"

  //	Runner.exit
  exit(mWhy1, msg) {
    var _, j, len, s, test, whyPhrase;
    this.mWhy = mWhy1;
    this.assert(this.mWhy != null);
    this.tassert(this.mWhy, "number");
    clearInterval(this.runnerThread);
    this.bRunning = false;
    whyPhrase = `${this.WHY_LIST[this.mWhy]}(${this.mWhy})${SP.d(msg, `details=${msg}`)}`;
    //		@lg "Runner.exit: #{whyPhrase}"
    //		@lg @one()
    this.secsElapsed = Math.ceil((Date.now() - this.msStart) / 1000);
    if (this.pass || this.failList.length) {
      _ = Base.openMsgGet();
      console.log(`${_}UT: [${this.secsElapsed} ${S.PLURAL("second", this.secsElapsed)}] total=${this.pass + this.failList.length}: ${(!this.failList.length ? "PASS" : "pass")}=${this.pass} ${(this.failList.length ? "FAIL" : "fail")}=${this.failList.length}`);
      if (Base.openCntGet()) {
        this.eventFire("left-open");
      }
    }
    this.summary = {
      fail: this.failList.length,
      frag: this.frag = `[${this.secsElapsed}s]  pass=${this.pass} fail=${this.failList.length}`,
      mWhy: this.mWhy,
      pass: this.pass,
      why: this.WHY_LIST[this.mWhy],
      whyPhrase: whyPhrase,
      whyMsg: msg
    };
    //		@lg "report.summary", @summary
    this.eventFire("runner-done", {
      mWhy: this.mWhy,
      msg: msg
    });
    if (this.failList.length) {
      //			@lg "calling reject"
      return this.reject(this);
    } else {
      if (trace.TRACE_DURATION_REPORT && g_testList.length) {
        s = `\nTests longer than ${trace.TRACE_DURATION_MIN_MS}ms:`;
        g_testList.sort(function(a, b) {
          if (a.msDur > b.msDur) {
            return -1;
          } else {
            return 1;
          }
        });
        for (j = 0, len = g_testList.length; j < len; j++) {
          test = g_testList[j];
          if (test.msDur > trace.TRACE_DURATION_MIN_MS) {
            if (s) {
              log(s);
              s = null;
            }
            log(`> ${test.msDur}: ${test.tn}     ${test.path}`);
          }
        }
      }
      //			@lg "Runner calling final resolve"
      return this.resolve(this);
    }
  }

  multi() {
    var s;
    s = this.one();
    return s += g_testList.reduce(((acc, test) => {
      if (test.mState === this.STATE_RUNNING) {
        return acc + `\nrunning: ${test.one2()}`;
      } else {
        return acc;
      }
    }), '');
  }

  one() {
    return `UTRunner: tests=${g_testList.length} enabled=${this.enabledCnt} sync=${this.syncCnt} async=${this.asyncCnt} waiting=${this.selectList.length} bRunning=${this.bRunning} running=${this.runningCnt} mutexes=${AsyncTest.s_one()}`;
  }

  //DEFAULT #OVERRIDE
  onEvent(eventName, primative, test, opts) {}

  //		@lg "Runner: onEvent: #{eventName}"
  onEventCLIOptionList() {}

  onEventCLIFlag() {}

  onEventLeftOpen() {}

  onEventRunnerDone() {}

  onEventRunnerStart() {}

  onEventTestDone() {}

  onEventTestStart() {}

  // Runner.run
  run() {
    Object.defineProperties(this, {
      "@who": {
        enumerable: true,
        value: "UNIT TEST RUNNER"
      },
      msStart: {
        value: Date.now()
      }
    });
    return new Promise((resolve1, reject1) => {
      this.resolve = resolve1;
      this.reject = reject1;
      this.testsSort();
      this.CLI(this.argv.slice(2));
      //H: runner-done can be called without runner-start
      //			console.log "bRunning=#{@bRunning}"
      if (this.bRunning) {
        this.eventFire("runner-start");
        this.testsValidate();
        this.testsEnable();
        //				console.log "count(STATE_WAITING)=#{@count @STATE_WAITING}"
        if (this.count(this.STATE_WAITING) > 0) {
          // now that cleanup can be async can't run all sync tests instantly because after() code contains Promise code
          //				for testIndex,i in @selectList by -1
          //					if (test=g_testList[testIndex-1]).isAsyncRunnable()
          //						@selectList.splice i, 1
          //						@testStart test

          //HACK: utilize this timer to keep node running until all tests have completed
          return this.runnerThread = setInterval(() => {
            //						@lg "RUNNING: #{@bRunning}"
            if (this.bRunning) {
              return this.startAnotherMaybe();
            }
          }, REMOVE_ME_MS);
        } else {
          return this.exit(this.WHY_NO_TESTS_FOUND); //H: what if tests still RUNNING? (not just waiting)
        }
      }
    });
  }

  startAnotherMaybe() {
    var i, j, ref, results, test, testIndex;
    this.assert(this.bRunning);
    if (this.selectList.length === 0 && this.runningCnt === 0) {
      return this.exit(this.WHY_ALL_TESTS_RUN);
    } else {
      ref = this.selectList;
      //			@lg "startAnotherMaybe: syncTestsCount=#{syncTestsCount}"
      results = [];
      for (i = j = ref.length - 1; j >= 0; i = j += -1) {
        testIndex = ref[i];
        if (syncTestsCount === 0) {
          test = g_testList[testIndex - 1];
          this.eq(test.mState, this.STATE_WAITING, "test isn't in waiting state");
          if (test.isAsyncRunnable()) { // @lg "can't run '#{test.one()}' because mutex '#{test.opts.mutex}' already running"
            this.selectList.splice(i, 1);
            results.push(this.testStart(test));
          } else if (test.bSync) {
            this.selectList.splice(i, 1);
            //						@lg "STARTING NEXT TEST"
            results.push(this.testStart(test));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results; //R
    }
  }

  testDone(test) {
    var _;
    this.pass += test.pass;
    this.failList.push(...test.failList); //PATTERN #ARRAY #IN-PLACE #ARRAY-APPEND PREV:@failList = [...@failList, ...test.failList]
    this.runningCnt--;
    this.logg(trace.UT_SYS, `testDone: p/f=${this.pass}/${this.failList.length} concurrent=${this.runningCnt}: ${test.one()}: [${this.one()}]`);
    if (test.failList.length && this.OPTS.mFailMode === this.FM_FAILTEST) {
      //			@stack _="mFailMode=@FM_FAILTEST: test failure without recovery: #{test.one2()}"
      _ = `mFailMode=@FM_FAILTEST: test failure without recovery: ${test.one2()}`;
      return this.exit(this.WHY_FAIL_FAST, `${test.failList.length} error(s)`);
    } else if (this.count(this.STATE_WAITING) === 0 && this.runningCnt === 0) { //H: correct? or only let other area do it?
      return this.exit(this.WHY_ALL_TESTS_RUN);
    }
  }

  testsEnable() {
    var add, i, idx, j, l, len, len1, len2, len3, len4, len5, len6, p, q, r, ref, ref1, ref2, ref3, test, testIndex, u, w;
    this.assert(this.selectList.length === 0);
    if (g_testList.length > 0) {
      add = (test) => {
        return this.selectList.unshift(test.testIndex);
      };
      //			g_testList.forEach (test) =>
      //				@lg ">" + test.one3()
      //				if test.opts.bManual
      //					@lg "MANUAL"

      // 			-a always overrides capitals (if any happen to be set)
      if (this.OPTS.testsAll) {
        g_testList.forEach((test) => {
          if (!test.opts.bManual) {
            return add(test);
          }
        });
      } else if (this.OPTS.keystrue) {
        for (j = 0, len = g_testList.length; j < len; j++) {
          test = g_testList[j];
          if (O.INTERSECTION(test.keys, this.OPTS.keystrue)) {
            add(test);
          }
        }
      } else if (this.OPTS.bAsync) {
        for (l = 0, len1 = g_testList.length; l < len1; l++) {
          test = g_testList[l];
          if (/^[aA]$/.test(test.cmd)) {
            if (!test.opts.bManual) {
              add(test);
            }
          }
        }
      } else if (this.OPTS.bSync) {
        for (p = 0, len2 = g_testList.length; p < len2; p++) {
          test = g_testList[p];
          if (/^[tT]$/.test(test.cmd)) {
            if (!test.opts.bManual) {
              add(test);
            }
          }
        }
      } else if (this.OPTS.testsInclude) {
        ref = this.OPTS.testsInclude.split(',');
        for (q = 0, len3 = ref.length; q < len3; q++) {
          testIndex = ref[q];
          this.selectList.unshift(testIndex * 1); //PATTERN
        }
      } else {
        // 				override capitals
        g_testList.forEach((test) => {
          if (/^[A-Z]/.test(test.cmd)) {
            //						@lg "found ut override: #{test.tn}"
            return add(test);
          }
        });
      }
      if (this.selectList.length === 0) {
        // 				default scenario: no CLI #, no CLI -a, no capital overrides
        g_testList.forEach((test) => {
          if (!test.opts.bManual) {
            return add(test);
          }
        });
      }
      if (this.OPTS.testsIgnore) {
        ref1 = this.OPTS.testsIgnore.split(',');
        // 				doesn't matter if default all (no capital overrides), -a, include list, or override capitals, you can always ignore specific tests
        for (r = 0, len4 = ref1.length; r < len4; r++) {
          testIndex = ref1[r];
          this.selectList = this.selectList.filter(function(i) {
            return i !== testIndex * 1;
          });
        }
      }
      //			if @OPTS.keysfalse
      //				for test in g_testList
      //					if O.INTERSECTION test.keys, @OPTS.keysfalse
      //						bTODO="remove from @selectList"

      //			@lg "bOnline", @OPTS.bOnline
      if (!this.OPTS.bOnline) {
        this.lg("OFFLINE");
        this.selectList = this.selectList.filter((i) => {
          return !g_testList[i - 1].tags.internet;
        });
      }
      ref2 = this.selectList;
      for (u = 0, len5 = ref2.length; u < len5; u++) {
        i = ref2[u];
        g_testList[i - 1].enable();
      }
      if (0) {
        this.lg("-----> VERIFY REVERSE ORDER:");
        ref3 = this.selectList;
        for (idx = w = 0, len6 = ref3.length; w < len6; idx = ++w) {
          i = ref3[idx];
          this.lg(`[${idx}] -----> ${i} -> ${g_testList[i - 1].one2()}`);
        }
      }
      this.enabledCnt = g_testList.reduce((function(acc, test) {
        if (test.bEnabled) {
          return acc + 1;
        } else {
          return acc;
        }
      }), 0);
      this.syncCnt = g_testList.reduce((function(acc, test) {
        if (test.bEnabled && test.bSync) {
          return acc + 1;
        } else {
          return acc;
        }
      }), 0);
      this.asyncCnt = g_testList.reduce((function(acc, test) {
        if (test.bEnabled && !test.bSync) {
          return acc + 1;
        } else {
          return acc;
        }
      }), 0);
      return this.lg(`${this.summary} Found ${g_testList.length} ${S.PLURAL("test", g_testList.length)}${SP.d(this.enabledCnt < g_testList.length, `with ${this.enabledCnt} enabled`)}`);
    }
  }

  testsSort() {
    var i, j, len, results, test, testIndex;
    g_testList.reverse(); //IMPORTANT: g_testList must be in reverse order so that we can splice way elements and not break our iterators
    
    //		_ = []
    //		g_testList.forEach (test) =>
    //			unless test.bSync
    //				_.push test
    //		g_testList.forEach (test) =>
    //			if test.bSync
    //				_.push test

    //		g_testList = _
    testIndex = 1;
    results = [];
    for (i = j = 0, len = g_testList.length; j < len; i = ++j) {
      test = g_testList[i];
      test.testIndex = testIndex++;
      test.runner = this;
      test.bEnabled = false;
      test.mStage = this.STAGE_SETUP;
      test.mState = this.DISABLED;
      results.push(test.testMutex != null ? test.testMutex : test.testMutex = '');
    }
    return results; //R
  }

  //			@lg "[#{i}] pre: #{test.one()}"
  testStart(test) {
    this.runningCnt++;
    //		@lg "testStart: concurrent now=#{@runningCnt}: #{test.one()}"
    return test.start();
  }

  testsValidate() {
    var j, len, test;
    for (j = 0, len = g_testList.length; j < len; j++) {
      test = g_testList[j];
      test.optsValidate();
    }
    return this.summary = `[NEG=${this.mTypeCtrList[0]} PROOF=${this.mTypeCtrList[1]}]`;
  }

};

//END:UTRunner
UT_UT = class UT_UT extends UT { //@UT_UT		@unittest  @ut
  run() {
    this.s("@p - async return implicit Promise", function() {
      this.p("resolved", function() {
        return Promise.resolve("I am good");
      });
      this.p("rejected", {
        expect: "EXCEPTION",
        mType: this.NEG
      }, function() {
        return Promise.reject("I am bad");
      });
      this.p("non-promise", {
        expect: "ERROR",
        mType: this.NEG
      }, function() {
        return Math.pi;
      });
      return this.p("@p and @ce together", {
        desc: "role model of how to use @p and @ce together.  see file header for full explanation"
      }, function() {
        var pr;
        return pr = this.ce().run().then((po) => {
          return this.env.d(); //WORKS
        });
      });
    });
    this.s("top", function() {
      this.t("test1", function() {});
      return this.t("test2", function() {});
    });
    this.s("top", function() {
      return this.s("middle", function() {
        this.t("test1", function() {});
        return this.t("test2", function() {});
      });
    });
    //COMMENTED-OUT
    //		@t "UT events", (ut) ->
    //			@testHub.startClient "/tmp/ut/UT_UT"
    //			.then (client) =>
    //				@log "one: #{client.one()}"
    //			.catch (ex) =>
    //				@logCatch "startClient", ex		#H: logCatch WHAT should be the parameter?
    this.t("opts", function(ut) {
      this.human("ut.opts", ut.opts);
      this.eq(ut.opts.utUDOptionName, "utUDOptionValue");
      this.log("@opts=", this.opts);
      this.eq(this.opts.utUDOptionName, "utUDOptionValue");
      return this.eq(this.get42(), 42);
    });
    this.s("bag", function() {
      this.t("set", function() {
        this.bag();
        this.bag.color = "red";
        return this.bag();
      });
      this.t("get", function() {
        this.bag();
        this.eq(this.bag.color, "red");
        this.bag.clear();
        this.eq(this.bag.color, void 0);
        return this.bag();
      });
      return this.t("clear invalid", function() {
        var ex;
        try {
          this.bag.clear = "this should fail";
          return this.FAIL(this.FAIL_ERROR, "it's illegal to assign 'clear' to bag", "", this.bag);
        } catch (error) {
          ex = error;
          return this.PASS();
        }
      });
    });
    this.s("sync nesting test", function() {
      return this.s("a", (ut) => {
        //				@log "section log"
        //				@logError "section logError"
        //				@logCatch "section logCatch"
        this.s("b1", function() {
          this.t("b1c1", function() {});
          //						@log "test log"
          //						@logError "test logError"
          //						@logCatch "test logCatch"
          return this.t("b1c2", function() {});
        });
        return this.s("b2", function() {
          return this.s("b2c1", function() {
            return this.t("b2c1d1", function() {});
          });
        });
      });
    });
    this.s("async nesting test", function() {
      this.s("a", function() {
        this.s("b1", function(ut) {
          this.a("b1c1", function(ut) {
            return setTimeout((() => {
              return ut.resolve();
            }), 10);
          });
          //						@log "setTimeout"
          //						@log "asynch log"
          //						@logError "asynch logError"
          //						@logCatch "asynch logCatch"
          return this.a("b1c2", function() {
            return this.resolve();
          });
        });
        return this.s("b2", function() {
          return this.s("b2c1", function() {
            return this.t("one", function() { // needs to be here to test stack
              this.human(this.one());
              return this.human(this.one2());
            });
          });
        });
      });
      return this.a("b2c1d1", function() {
        return this.resolve();
      });
    });
    this.a("@delay", function() {
      return this.delay(50).then((to) => {
        this.log("timed out", to);
        return this.resolve(to);
      });
    });
    this.s("eqfile", function() {
      this.p("same size", function() {
        return this.eqfile(this.filepath("deanna.png"), this.filepath("same-size.png"));
      });
      this.p("different sizes", {
        expect: "EQ",
        mType: this.NEG
      }, function() {
        return this.eqfile(this.filepath("deanna.png"), this.filepath("ut.env"));
      });
      this.p("a dne", {
        expect: "EQ",
        mType: this.NEG
      }, function() {
        return this.eqfile(this.filepath("dne.png"), this.filepath("ut.env"));
      });
      return this.p("b dne", {
        expect: "EQ",
        mType: this.NEG
      }, function() {
        return this.eqfile(this.filepath("deanna.png"), this.filepath("dne.env"));
      });
    });
    this.s("equate", function() {
      this.t("single parameter", {
        expect: "EQ,EQ",
        onEq: function(fail) {
          return this.log("inside onEq");
        }
      }, function() {        //					fail.heal()
        this.eq(1, 2);
        this.eq("only passed one parameter");
        return this.eq(1, 2);
      });
      this.t("differing types (loose)", {
        desc: "@eq is NOT strict, i.e., it checks VALUE only (string vs. integer is okay and passes)"
      }, function() {
        return this.eq("5", 5);
      });
      this.t("differing types (kinda POS)", {
        desc: "@Eq is kinda strict, i.e., it checks VALUE only (string vs. string is okay and passes)"
      }, function() {
        return this.Eq("peter", "peter");
      });
      this.t("differing types okay (kinda NEG 22222)", {
        desc: "@Eq is kinda strict"
      }, function() { // :"EQ", mType:@NEG, ->
        return this.Eq("5", 5);
      });
      this.t("differing types (strict POS)", {}, function() {
        return this.EQ(new String("peter"), new String("peter"));
      });
      this.t("differing types (strict NEG)", {
        expect: "EQ",
        desc: "@EQ is strict!, i.e., VALUE and TYPE must agree!",
        mType: this.NEG
      }, function() {
        return this.EQ("peter", new String("peter"));
      });
      this.t("EQO", {
        desc: "@EQO same object"
      }, function() {
        var o;
        o = {
          a: "a"
        };
        return this.EQO(o, o, "same object");
      });
      return this.t("EQO neg 33333", {
        expect: "EQ",
        desc: "@EQO same object",
        mType: this.NEG
      }, function() {
        return this.EQO({
          a: "a"
        }, {
          a: "a"
        }, "different objects (with same object signatures)");
      });
    });
    this.s("exceptions", function() {
      return this.a("throw exception", {
        expect: "EXCEPTION",
        mType: this.NEG
      }, function() {
        throw Error("this is error");
      });
    });
    this.s("options", function() {
      this.s("general", function() {
        return this.t("commented out", {
          _desc: "this is not used"
        }, function() {});
      });
      return this.s("one by one", function() {
        this._t("bManual", function(ut) {});
        this._t("desc", function(ut) {});
        this.t("exceptionMessage", {
          exceptionMessage: "Deanna is beautiful",
          mType: this.NEG
        }, function() {
          throw Error("Deanna is beautiful");
        });
        this.s("expect", function() {
          this.s("assert", function() {
            this.t("pos", function() {
              return this.assert(true, "Saturday");
            });
            return this.t("neg", {
              expect: "ASSERT",
              mType: this.NEG
            }, function() {
              return this.assert(false, "Sunday");
            });
          });
          this.t("bManual: fatal", {
            desc: "can't test because it exits node",
            bManual: true
          }, function() {
            this.fatal();
            return this.fatal("display me on console");
          });
          return this.a("promise timeout", {
            timeout: 10,
            expect: "TIMEOUT",
            mType: this.NEG
          }, function() {});
        });
        //						DO NOT CALL ut.resolve()				@_t "hang", (ut) ->
        //				@t "seek exception but don't get one", expect:"EXCEPTION",mType:@NEG, ->
        //					@log "hello"
        this._t("markers", function(ut) {});
        this._t("mkr", function(ut) {});
        this._t("mType", function(ut) {});
        this._t("mutex", function(ut) {});
        this._t("onAssert", function(ut) {});
        this._t("onEq", function(ut) {});
        this._t("onError", function(ut) {});
        this._t("onException", function(ut) {});
        this.a("onTimeout", {
          timeout: 10,
          onTimeout: function(ut) {
            // @log "opts", ut.opts			#MOST-BIZARRE BUG EVER!  the get: property of ut was opening connection:
            // __76  > ∟ user: ut
            // __77  40:58 [TestHub] open ut
            // __78  40:58 [TestHub] auditOpen SQL-ut: count=1
            this.log("fail", ut.fail);
            this.log(`onTimeout called: ${ut.opts.timeout}=${this.opts.timeout}`);
            return ut.fail.heal();
          }
        }, function() {
          return this.log("do not call resolve in order to force timeout");
        });
        this._t("onUnfail", function(ut) {});
        this._t("onUnexpectedPromise", function(ut) {});
        this._t("SO", function(ut) {});
        this._t("RUNTIME_SECS", function(ut) {});
        this.t("t bTraceRecommended", {
          ty: "FB_GET,FB_GET_404"
        }, function() {
          if (this.opts.bTraceRecommended) {
            this.assert(trace.FB_GET);
            return this.assert(trace.FB_GET_404);
          } else {

          }
        });
        this._t("tags", function(ut) {});
        this.a("timeout", {
          timeout: 1000
        }, function(ut) {
          //					@log "opts parameter"
          //					O.LOG ut.opts
          this.eq(ut.opts.timeout, 1000);
          return ut.resolve();
        });
        this._t("tru", function(ut) {});
        this._t("ty", function(ut) {});
        this._t("url", function(ut) {});
        return this._t("USER_CNT", function(ut) {});
      });
    });
    this.s("logging", function() {
      this.t("log no arguments", function() {
        if (trace.HUMAN) {
          this["log"]();
          return this["log"]();
        }
      });
      this.t("maxDepth 1", function() {
        var deep;
        deep = {
          L1: {
            L2: {
              L3: {
                L4: {
                  I_AM_L5: true
                }
              }
            }
          }
        };
        this.logg(trace.HUMAN, "maxDepth:0", deep, {
          maxDepth: 0 //WTF: what does this even mean?   Just give summary counts of various things
        });
        this.logg(trace.HUMAN, "maxDepth:1", deep, {
          maxDepth: 1
        });
        this.logg(trace.HUMAN, "maxDepth:2", deep, {
          maxDepth: 2
        });
        this.logg(trace.HUMAN, "maxDepth:3", deep, {
          maxDepth: 3
        });
        this.logg(trace.HUMAN, "maxDepth:4", deep, {
          maxDepth: 4
        });
        this.logg(trace.HUMAN, "maxDepth:5", deep, {
          maxDepth: 5
        });
        return this.logg(trace.HUMAN, "maxDepth:6", deep, {
          maxDepth: 6
        });
      });
      this.t("maxDepth 22", function() {
        var L1;
        L1 = {
          L1P: "L1P",
          L2: {
            L2P: "L2P",
            L3: {
              L3P: "L3P",
              L4: {
                L4P: "L4P"
              }
            }
          }
        };
        this.log("hello");
        this.logg(trace.HUMAN, "maxDepth:0", L1, {
          maxDepth: 0 //WTF: what does this even mean?   Just give summary counts of various things
        });
        this.logg(trace.HUMAN, "maxDepth:1", L1, {
          maxDepth: 1
        });
        this.logg(trace.HUMAN, "maxDepth:2", L1, {
          maxDepth: 2
        });
        this.logg(trace.HUMAN, "maxDepth:3", L1, {
          maxDepth: 3
        });
        this.logg(trace.HUMAN, "maxDepth:4", L1, {
          maxDepth: 4
        });
        this.logg(trace.HUMAN, "maxDepth:5", L1, {
          maxDepth: 5
        });
        return this.logg(trace.HUMAN, "maxDepth:6", L1, {
          maxDepth: 6
        });
      });
      this.t("logCatch", {
        expect: "EXCEPTION"
      }, function() {
        return this.logCatch("this is logCatch");
      });
      this.t("logError", {
        expect: "ERROR"
      }, function() {
        return this.logError("this is logError");
      });
      this.t("logSilent", function() {
        this.logSilent("you can't see me");
        this.logSilent("you can't see my object", {
          a: "a"
        });
        return this.logSilent("you can't see me in red", void 0, {
          format: "red"
        });
      });
      //TEST: format:red   doesn't throw right error
      return this.t("logTransient", function() {
        return this.logTransient("a blip");
      });
    });
    this.a("mutex", {
      mutex: "J"
    }, function(ut) {
      this.log("inside MUTEX");
      return ut.resolve();
    });
    this.a("mutex1", {
      mutex: "orange"
    }, function(ut) {
      this.log("M1: before");
      return this.delay(1000).then(() => {
        this.log("M1: after");
        return ut.resolve();
      });
    });
    this.a("mutex2", {
      mutex: "orange"
    }, function(ut) {
      this.log("M2: before");
      return this.delay(1000).then(() => {
        this.log("M2: after");
        return ut.resolve();
      });
    });
    this.a("parallel 1", {
      mutex: "P1"
    }, function(ut) {
      this.log("P1: before");
      return this.delay(1000).then(() => {
        this.log("P1: after");
        return ut.resolve();
      });
    });
    this.a("parallel 2", {
      mutex: "P2"
    }, function(ut) {
      this.log("P2: before");
      return this.delay(1000).then(() => {
        this.log("P2: after");
        return ut.resolve();
      });
    });
    this.p("@pass", function() {
      return this.passSetup(1, 2, (pass, passRec) => {
        //				console.log "PASS: #{pass} #{@passNbr} #{@pass_resolve}"
        return passRec.resolve();
      });
    });
    this.a("pass without explicit promise pattern", function() {
      var _resolve, doPass, promiseCreator;
      _resolve = null;
      promiseCreator = () => {
        return new Promise((resolve) => {
          return _resolve = resolve;
        });
      };
      doPass = (pass) => {
        var pr;
        pr = promiseCreator();
        this.h(`PASS=${pass}`);
        if (pass === 1) {
          _resolve();
        } else {
          this.resolve();
        }
        return pr;
      };
      return doPass(1).then(() => {
        return doPass(2);
      });
    });
    this.s("primatives", function() { // all the commands.. DEFINE TERMS!
      return this.t("h: header", function() {
        this.h("header 1");
        return this.h("header 2");
      });
    });
    this.s("promises", function() {
      this.t("synchronous", {
        expect: "UNEXPECTED_PROMISE",
        mType: this.NEG
      }, function() {
        return Promise.resolve();
      });
      return this.a("too late", async function(ut) {
        //BEFORE-FIXED:
        // _685  29:33 [UTRunnerFBNode] testDone: p/f=1/0 concurrent=0: #106 a UT_UT promises/too late: [UTRunner: tests=256 enabled=1 sync=0 async=1 waiting=0 bRunning=true running=0 mutexes=same (1)]
        // _686  29:33 [UTRunnerFBNode] All closed.    All unit tests completed: [1 second] total=1: PASS=1 fail=0
        // _687  29:33 [UT_UT/too late] one3=Test: #106 a UT_UT promises/too late: cmd=a enabled=true mState=DONE(3) mStage=1 mutex=same pf=1/0 []
        // _688  29:33 [UT_UT/too late] @a returned promise. WHAT DO? resolved value= NULL

        //YES
        //				@env = await @ce().run()
        //				@env.succ()

        //NO
        //				@resolve()
        //				Promise.resolve()

        //NO
        //				new Promise (resolve, reject) =>
        //					@resolve()

        //MRC
        this.resolve();
        await this.delay(100); //ABOVE => async function(ut) { ... }
        return "peter"; // still returns promise because of implicit "async" above
      });
    });
    return this.t("trace.T", function() {
      var keep;
      keep = this.runner.UT;
      this.log("keep", keep);
      trace.stackOnePush("UT", 55);
      this.eq(this.runner.UT, 55, "set?");
      //			@log "yes show"	#, @trace
      this.runner.UT = false;
      this.eq(this.runner.UT, false, "false?");
      //			@log "no show"	#, @trace
      trace.stackOnePop("UT");
      return this.eq(this.runner.UT, keep, "keep");
    });
  }

};

//		@t "clash with built-in", {mType:@NEG}, (ut) ->
//			@log "clash"
//			drill this
//			@delay = 10			
//END:UT_UT
module.exports = EXPORTED;
